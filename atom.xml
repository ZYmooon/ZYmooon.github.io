<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懒人漫游</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-24T02:16:33.576Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zymooon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hahah.md</title>
    <link href="http://yoursite.com/2018/03/24/hahah-md/"/>
    <id>http://yoursite.com/2018/03/24/hahah-md/</id>
    <published>2018-03-24T02:15:32.000Z</published>
    <updated>2018-03-24T02:16:33.576Z</updated>
    
    <content type="html"><![CDATA[<p>dsadsadasd</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dsadsadasd&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>几种常见的布局</title>
    <link href="http://yoursite.com/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/03/23/常见的几种布局/</id>
    <published>2018-03-22T16:58:21.000Z</published>
    <updated>2018-03-24T00:46:02.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 几种常见的布局：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>理解布局的概念<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="一-理解布局的概念"><a href="#一-理解布局的概念" class="headerlink" title="一:理解布局的概念"></a>一:理解布局的概念</h2><ul><li><h3 id="静态布局"><a href="#静态布局" class="headerlink" title="静态布局:"></a>静态布局:</h3><p>  浏览器中显示网页,通过横向或者纵向滚动条来查阅改页面内容,意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；</p></li><li><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局:"></a>弹性布局:</h3><p>  flex局部CSS3引入的一个很强大的布局方式,用来替代以前Web开发人员使用的一些复杂而易错hacks方法</p><p>  其中flex-flow是flex-direction和flex-wrap属性的简写形式,语法如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-flow:||</span><br><span class="line">flex-direction: row | row-reverse(相反) | column | colum-reverse;</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure></li><li><h3 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h3><p>  自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。你可以把自适应布局看作是静态布局的一个系列。就是说你看到的页面，里面元素的位置会变化而大小不会变化</p></li><li><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,inital-scale=1.0,maximum-scale=1.0,minimum-scale=1.0</span><br><span class="line">,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>name=”viewport” 名称=视图</li><li>width=device-width 页面宽度=设备宽度(可以理解为获取你手机的屏幕宽度)</li><li>initial-scale - 初始的缩放比例</li><li>minimum-scale - 允许用户缩放到的最小比例</li><li>maximum-scale - 允许用户缩放到的最大比例</li><li>user-scalable - 用户是否可以手动缩放</li></ul></li></ul><p>在做响应式布局的时候,必须以及一定要加上的重要头部代码.分别为不同的屏幕分辨率定义布局,同时，在每个布局中,即页面元素宽度随着窗口调整而自动适配。每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p><h2 id="二-响应式布局的步骤"><a href="#二-响应式布局的步骤" class="headerlink" title="二:响应式布局的步骤:"></a>二:响应式布局的步骤:</h2><ul><li><h3 id="布局及设置meta标签"><a href="#布局及设置meta标签" class="headerlink" title="布局及设置meta标签:"></a>布局及设置meta标签:</h3><p>  在写响应式布局之前,可以先完成非响应式布局,页面固定宽度大小,如果完成了非响应式那么我在去添加媒体查询（Media Query)和响应式代码。这种操作更容易实现响应式特性。</p><p>  当你完成当你已经完成了无响应的网站，做的第一件事是在你的 HTML 页面，粘贴下面的代码到和标签之间。这将设置屏幕按1：1的尺寸显示，在 iPhone 和其他智能手机的浏览器提供网站全视图浏览，并禁止用户缩放页面。</p><p>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot; /&gt;</code></p></li><li><h3 id="通过媒体查询来设置样式-media-query"><a href="#通过媒体查询来设置样式-media-query" class="headerlink" title="通过媒体查询来设置样式 :media query"></a>通过媒体查询来设置样式 :media query</h3><p>  media query是响应式设计的核心，它能够和浏览器进行沟通，告诉浏览器页面如何呈现，假如一个终端的分辨率小于980px，那么可以这样写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:980px)&#123;</span><br><span class="line">    #head&#123;&#125;</span><br><span class="line">    #content&#123;&#125;</span><br><span class="line">    #footer&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里面的样式会覆盖掉之前所定义的样式。</p></li></ul><ul><li><h3 id="设置多种视图宽度"><a href="#设置多种视图宽度" class="headerlink" title="设置多种视图宽度"></a>设置多种视图宽度</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**ipad**/</span><br><span class="line">@media only screen and (min-width:768px)and(max-width:1024px)&#123;&#125;</span><br><span class="line">/**iphone**/</span><br><span class="line">@media only screen and (width:320px)and (width:768px)&#123;&#125;</span><br></pre></td></tr></table></figure><p>  假如需要兼容ipad和iphone,就可以使用种写法.</p></li><li><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>  在做pc端的时候,我们习惯于写px作为像素单位,但是在移动端,在做响应式<br>  布局的时候,我们需要将字体也做成响应式的.根据屏幕的尺寸变化而变化,<br>  这个时候,我们需要用到css3新的单位,rem.<br>  rem是相对于根元素的字体大小的单位.我习惯称呼为动态rem.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:100%;&#125;</span><br><span class="line">//完成后，你可以定义响应式字体：</span><br><span class="line">@media (min-width:640px)&#123;body&#123;font-size:1rem;&#125;&#125;</span><br><span class="line">@media (min-width:960px)&#123;body&#123;font-size:1.2rem;&#125;&#125;</span><br><span class="line">@media (min-width:1200px)&#123;body&#123;font-size:1.5rem;&#125;&#125;</span><br></pre></td></tr></table></figure><p>  <strong>切记,!!!</strong>一定要重置根元素字体大小.</p></li></ul><p>下面有几个例子可以参考看看:</p><p><a href="http://js.jirengu.com/camusidemo/1/edit?html,output" target="_blank" rel="noopener">flex布局</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 几种常见的布局：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;理解布局的概念&lt;br&gt;
    
    </summary>
    
      <category term="布局" scheme="http://yoursite.com/categories/%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="flex和响应式" scheme="http://yoursite.com/tags/flex%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>生命周期中的哪些钩子函数</title>
    <link href="http://yoursite.com/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/03/23/生命周期/</id>
    <published>2018-03-22T16:58:21.000Z</published>
    <updated>2018-03-23T22:17:58.343Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong> 生命周期中的哪些钩子函数：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>生命周期的钩子函数<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="关于学习-Vue-的生命周期钩子函数"><a href="#关于学习-Vue-的生命周期钩子函数" class="headerlink" title="关于学习 Vue 的生命周期钩子函数"></a>关于学习 Vue 的生命周期钩子函数</h2><p>我们需要详细的了解,这会在写代码的时候,达到事半功倍的效果,可以帮我们很快的找出错误和解决需要,详情请见<a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener">vue</a>的这个章节</p><p>在Vue的官方文档中,给出了生命周期图示<br><img src="http://upload-images.jianshu.io/upload_images/8168023-334da70244e85c6d..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图示"></p><p>我们可以看到,这个图描述的Vue的生命周期从创建实例到销毁的过程<br>下面我们详细的说说Vue中有哪些什么周期钩子函数</p><blockquote><p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p></blockquote><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate:"></a>beforeCreate:</h4><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p><h4 id="created"><a href="#created" class="headerlink" title="created:"></a>created:</h4><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><ul><li>可以拿到数据</li><li>可以调用实例和方法</li><li>在这个生命周期钩子函数中适宜做异步请求</li></ul><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount:"></a>beforeMount:</h4><p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br>也就是说DOM还未被渲染</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted:"></a>mounted:</h4><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>DOM已经被渲染,初始数据DOM渲染完毕,可以获取DOM</p><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p><h4 id="updated"><a href="#updated" class="headerlink" title="updated:"></a>updated:</h4><p>数据更新完毕,如果对数据做统一的处理,在updated中处理<br>,如果想分别区分不同的数据更新,同时对DOM操作,用nextTick</p><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h4 id="watch-对具体某个函数变化作统一处理"><a href="#watch-对具体某个函数变化作统一处理" class="headerlink" title="watch:对具体某个函数变化作统一处理"></a>watch:对具体某个函数变化作统一处理</h4><h4 id="nextTick-处理某个数据的某一次变化"><a href="#nextTick-处理某个数据的某一次变化" class="headerlink" title="nextTick:处理某个数据的某一次变化"></a>nextTick:处理某个数据的某一次变化</h4><h4 id="created-可以获取数据-调用一部数据-调用方法"><a href="#created-可以获取数据-调用一部数据-调用方法" class="headerlink" title="created:可以获取数据,调用一部数据,调用方法"></a>created:可以获取数据,调用一部数据,调用方法</h4><p>updata在nextTick之前触发</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt; 生命周期中的哪些钩子函数：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;生命周期的钩子函数&lt;br&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
</feed>
