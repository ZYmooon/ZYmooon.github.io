<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>简单了解webpack和npm</title>
      <link href="/2018/03/25/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3webpack%E5%92%8Cnpm/"/>
      <url>/2018/03/25/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3webpack%E5%92%8Cnpm/</url>
      <content type="html"><![CDATA[<p><strong> 简单了解webpack和npm：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="如何全局安装一个-node-应用"><a href="#如何全局安装一个-node-应用" class="headerlink" title="如何全局安装一个 node 应用?"></a>如何全局安装一个 node 应用?</h2><p><code>npm install -g</code></p><h2 id="package-json-有什么作用？"><a href="#package-json-有什么作用？" class="headerlink" title="package.json 有什么作用？"></a>package.json 有什么作用？</h2><p>npm上发布包时，需要<code>npm init</code>生成package.json文件<br>package.json中的信息来描述这个包,并提供包所需要的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;gulp-use&quot;,//发布npm包的时候需要的，表示npm包的名字</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,//包的版本号</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,//对于这个包的简单描述</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,//入口文件</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;//</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],// 关键字</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,//作者</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,//</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;,//所依赖的其他包的版本号</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="npm-install-–save-app-与-npm-install-–save-dev-app有什么区别"><a href="#npm-install-–save-app-与-npm-install-–save-dev-app有什么区别" class="headerlink" title="npm install –save app 与 npm install –save-dev app有什么区别?"></a>npm install –save app 与 npm install –save-dev app有什么区别?</h2><ul><li><p><code>npm install --save app</code>: 保存需要加载的依赖的信息到package.json里面,该模块使用时，该依赖被调用</p></li><li><p><code>npm install --save-dev app</code>: 开发测试时使用的依赖，当需要测试时，可以调用该依赖</p></li></ul><h4 id="node-modules的查找路径是怎样的"><a href="#node-modules的查找路径是怎样的" class="headerlink" title="node_modules的查找路径是怎样的?"></a>node_modules的查找路径是怎样的?</h4><p>该模块的同级目录下查找nodule_modules =&gt; if(没有) 向上一级查找 =&gt; if(没有) 再向上一级 …=&gt; 直到找到根目录下</p><h4 id="webpack是什么？和其他同类型工具比有什么优势？"><a href="#webpack是什么？和其他同类型工具比有什么优势？" class="headerlink" title="webpack是什么？和其他同类型工具比有什么优势？"></a>webpack是什么？和其他同类型工具比有什么优势？</h4><p>市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。</p><p>这些已有的模块化工具并不能很好的完成如下的目标：</p><ul><li><p>将依赖树拆分成按需加载的块</p></li><li><p>初始化加载的耗时尽量少</p></li><li><p>各种静态资源都可以视作模块</p></li><li><p>将第三方库整合成模块的能力</p></li><li><p>可以自定义打包逻辑的能力</p></li><li><p>适合大项目，无论是单页还是多页的 Web 应用</p><h4 id="和其他同类型工具比有什么优势？"><a href="#和其他同类型工具比有什么优势？" class="headerlink" title="和其他同类型工具比有什么优势？"></a>和其他同类型工具比有什么优势？</h4></li></ul><p>webpack的优势：</p><ul><li>1.代码拆分</li></ul><p>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p><ul><li>2.Loader</li></ul><p>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p><ul><li>3.智能解析</li></ul><p>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。</p><ul><li>4.插件系统</li></ul><p>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</p><ul><li>5.快速运行</li></ul><p>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p><h2 id="npm-scripts是什么？如何使用？"><a href="#npm-scripts是什么？如何使用？" class="headerlink" title="npm scripts是什么？如何使用？"></a>npm scripts是什么？如何使用？</h2><p>npm 允许在package.json文件里面，使用scripts字段定义脚本命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node ./bin/www&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;webpack --config ./src/webpack.config.js&quot;,</span><br><span class="line">    &quot;watch&quot;: &quot;onchange \&quot;src/**/*.js\&quot;  \&quot;src/**/*.less\&quot; -- npm run webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>输入<br><code>npm run webpack</code><br> 或者<br> <code>npm run watch</code><br> 就可以执行对应的脚本<br>但是比如start 或 bulid 等，可以直接<code>npm start</code></p></the>]]></content>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于js数据类型</title>
      <link href="/2018/03/25/%E5%85%B3%E4%BA%8Ejs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/25/%E5%85%B3%E4%BA%8Ejs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><strong> 关于js数据类型：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>本文介绍关于JavaScript数据类型的相关知识<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>  JavaScript语言的每一个值，都属于某一种数据类型。JavaScript的数据类型，共有六种。</p><p>  数值（number）：整数和小数（比如1和3.14）</p><p>  字符串（string）：字符组成的文本（比如”Hello World”）</p><p>  布尔值（boolean）：true（真）和false（假）两个特定值</p><p>  undefined：表示“未定义”或不存在，即此处目前没有任何值</p><p>  null：表示空缺，即此处应该有一个值，但目前为空</p><p>  对象（object）：各种值组成的集合</p><p><strong>但是在最新的 ECMAScript 标准中定义了第七种数据类型</strong></p><p>  Symbol (ECMAScript 6 新定义)</p><h2 id="其中又分为简单类型和复杂类型"><a href="#其中又分为简单类型和复杂类型" class="headerlink" title="其中又分为简单类型和复杂类型"></a>其中又分为简单类型和复杂类型</h2><ul><li>数值(number)、字符串(string)、布尔值(boolean),以及后定义的Symbol 称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</li><li>将对象称为复杂类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器.如数组,函数等等</li><li>至于undefined和null，一般将它们看成两个特殊值。</li></ul><p>JavaScript有三种方法，可以确定一个值到底是什么类型。</p><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li><p>Object.prototype.toString 方法</p><p>typeof 运算符可以返回一个值的数据类型，可能有以下结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof 123 // &quot;number&quot;</span><br><span class="line">typeof &apos;123&apos; // &quot;string&quot;</span><br><span class="line">typeof false // &quot;boolean&quot;</span><br></pre></td></tr></table></figure><p>原始类型:数值、字符串、布尔值分别返回number、string、boolean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f</span><br><span class="line">// &quot;function&quot;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">typeof obj //object</span><br></pre></td></tr></table></figure><p>函数,返回的结果是function</p><p>对象,返回的结果是object</p></li></ul><h2 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h2><p>对于null和undefined，可以大致可以像下面这样理解。</p><p>null表示空值，即该处的值现在为空。典型用法是：</p><p>作为函数的参数，表示该函数的参数是一个没有任何内容的对象。<br>作为对象原型链的终点。<br>undefined表示不存在值，就是此处目前不存在任何值。典型用法是：</p><p>变量被声明了，但没有赋值时，就等于undefined。<br>调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>对象没有赋值的属性，该属性的值为undefined。<br>函数没有返回值时，默认返回undefined。</p><p>举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">function f(x)&#123;console.log(x)&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">var x = f();</span><br><span class="line">x // undefined</span><br></pre></td></tr></table></figure></p><ul><li><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><ul><li>两元逻辑运算符： &amp;&amp; (And)，|| (Or)</li><li>前置逻辑运算符： ! (Not)</li><li>相等运算符：===，!==，==，!=</li><li>比较运算符：&gt;，&gt;=，&lt;，&lt;=</li></ul></li><li><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript的数字类型和其它语言有所不同，没有整型和浮点数的区别，统一都是Number类型，可以表示十进制、八进制、十六进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 10; //十进制</span><br><span class="line">var b = 073; //八进制</span><br><span class="line">vat c = 0xf3; //十六进制</span><br></pre></td></tr></table></figure></li><li><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>String是Unicode字符组成的序列，俗称字符串，可以用双引号或者单引号表示，没有区别，匹配即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;;</span><br><span class="line">var str2 = &quot;zhouyi&quot;;</span><br><span class="line">var str3 = &apos;hello &quot;world&quot; &apos;;</span><br></pre></td></tr></table></figure></li><li><h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><p>对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。key我们称为对象的属性，value可以是任何JavaScript类型，甚至可以是对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">name: &apos;jirengu&apos;,</span><br><span class="line">age: 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>object的属性读取有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.name;</span><br><span class="line">obj[&apos;name&apos;];</span><br></pre></td></tr></table></figure></li><li><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = undefined;</span><br><span class="line">var a = null;</span><br></pre></td></tr></table></figure><p>上面代码中，a变量分别被赋值为’undefined’和’null’，这两种写法的效果几乎等价。</p><p>在’if’语句中，它们都会被自动转为’false’，相等运算符（’==’）甚至直接报告两者相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!undefined) &#123;</span><br><span class="line">  console.log(&apos;undefined is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// undefined is false</span><br><span class="line"></span><br><span class="line">if (!null) &#123;</span><br><span class="line">  console.log(&apos;null is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// null is false</span><br><span class="line"></span><br><span class="line">undefined == null</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>  上面代码说明，两者的行为是何等相似！Google公司开发的JavaScript语言的替代品Dart语言，就明确规定只有null，没有undefined！</p><p>  既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。</p><p>  1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(null) // 0</span><br><span class="line">5 + null // 5</span><br></pre></td></tr></table></figure><p>但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。</p><p>首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型和合成类型两大类，Brendan Eich觉得表示”无”的值最好不是对象。</p><p>其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。</p><p>因此，Brendan Eich又设计了一个undefined。他是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(undefined) // NaN</span><br><span class="line">5 + undefined // NaN</span><br></pre></td></tr></table></figure><p>但是，这样的区分在实践中很快就被证明不可行。目前null和’undefined’基本是同义的，只有一些细微的差别。<br>‘null’的特殊之处在于，JavaScript把它包含在对象类型（object）之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>上面代码表示，查询null的类型，JavaScript返回object（对象）。</p><p>这并不是说null的数据类型就是对象，而是JavaScript早期部署中的一个约定俗成，其实不完全正确，后来再想改已经太晚了，会破坏现存代码，所以一直保留至今。</p><p>注意，JavaScript的标识名区分大小写，所以undefined和null不同于Undefined和Null（或者其他仅仅大小写不同的词形），后者只是普通的变量名。<br>Boolean<br>布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><p>两元逻辑运算符： &amp;&amp; (And)，|| (Or)</p><p>前置逻辑运算符： ! (Not)</p><p>相等运算符：===，!==，==，!=</p><p>比较运算符：&gt;，&gt;=，&lt;，&lt;=</p><p>JavaScript有三种方法，可以确定一个值到底是什么类型。</p><ul><li><p>typeof运算符</p></li><li><p>instanceof运算符 </p></li><li><p>Object.prototype.toString方法</p></li></ul></li></ul></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>this详解</title>
      <link href="/2018/03/24/this%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/24/this%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong> this详解：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>我们来谈谈this吧<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>this,我相信很多JavaScript初学者都搞不懂this,包括我自己也是,很懵逼</p><h2 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h2><p>  由于运行期绑定的特性，JavaScript 中的 this 含义非常多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象</p><h2 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>  在函数直接调用时,this绑定到全局对象上.在浏览器,window就是该全局对象</p><p>  我们来看个例子<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p> <img src="https://upload-images.jianshu.io/upload_images/8168023-5f7f52173d98e75b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  在开发者工具中我们可以清楚的看到,第一个this是window对象,因为做了标记,第二个this也就是fn()调用后,打印出的也是window对象,所以充分说明,在函数直接调用时,window就是该全局对象</p><p>  还有,我们需要走出一个误区,这个误区就是,<strong>函数里的thisb不代表函数本身</strong><br>  下面继续看例子<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line">function fn1()&#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn()//100</span><br></pre></td></tr></table></figure></p><p>  结果打印出的是100<br>  也就是说,函数fn1中声明了a = 1,但是调用函数,里面打印出的值是外面的那个a,也就是说,fn1()里的this指向的还是全局对象,而不是它内部申明的那个a</p><p>  再来一个例子我们看看这个如果全局没有申明a,会是怎样</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn2()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8168023-466adecd063e64b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>结果是undefined,因为在全局上找不到a</p><p>注意,这次打印的是a,而不是直接打印this,所以结果不是window,因为全局对象上没有a</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>  看完外部调用,我们在来看看内部调用this,又将会打印出什么</p><p>  话不多说,无码无真相</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;</span><br><span class="line">  function children()&#123;</span><br><span class="line">    console.loh(this)</span><br><span class="line">  &#125;</span><br><span class="line">  children()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent()</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-5fc10c6435f91ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  你看,还是打印出的是this,为什么?</p><p>  首先会在函数内部找this，发现子函数里找不到this，那就去父函数找，还是找不到，最后就去父函数的外面也就是全局下找this，所以打印出的是window</p><p>  结论 : 函数嵌套产生的内部函数的this不是其父函数，仍然是全局变量.</p><h2 id="setTimeout、setInterval"><a href="#setTimeout、setInterval" class="headerlink" title="setTimeout、setInterval"></a>setTimeout、setInterval</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-a6f0737747b8a40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image.png"></p><p>  第一个this是绑定事件的这个元素，第二个this代表的全局对象window,如图所示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">    var me = this</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(me);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-fe8f46533b216f15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473" alt="image.png"></p><p>  如果在函数里申明了<code>var self = this</code>，那么第二个this就变掉了，相当于把第一个this代表的元素保存起来了，我们直接来看代码。如果看的有点绕的话，可以这么想，我可以不用_this，可以用me、self来代替_this，效果一样.</p><h2 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h2><p>  所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象</p><p>  new 运算符接受一个函数 F 及其参数：new F(arguments…)。这一过程分为三步：</p><ul><li><p>创建类的实例。这步是把一个空的对象的 <strong> </strong>proto__ __ 属性设置为 F.prototype 。</p><ul><li>初始化实例。函数 F 被传入参数并调用，关键字 this 被设定为该实例。</li><li>返回实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Byron&apos;);</span><br><span class="line">var p2 = new Person(&apos;Casper&apos;);</span><br><span class="line">var p3 = new Person(&apos;Vincent&apos;);</span><br><span class="line"></span><br><span class="line">p1.printName();</span><br><span class="line">p2.printName();</span><br><span class="line">p3.printName();</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/8168023-9b56f8ee60341655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>p1.printName();这句话执行的时候，先执行p1 = new Person(‘Byron’)，然后在new的时候，做了三件事，</p><ul><li><p>1、创建新的空对象</p></li><li><p>2、然后是把这个空的对象的 <strong>proto</strong> 属性设置为 Person.prototype </p></li><li><p>3、执行函数Person，遇到this，就认为this是刚才创建的对象，给它添加一个属性name，而这个属性的值就是函数Person的name</p></li></ul><p>执行完成之后，把新对象return出来赋值给p1<br>这样就可以通过p1的方式去用了</p><h2 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h2><p>  在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象，简单的来说，就是谁调用这个函数，这个函数指的就是谁（这个this就代表谁）。</p><p>  如：Object1.fn()，this指的就是Object1，<br>  假如：Object1.Object2.Object3.fn(),this指的就是Object3，<br>  <strong>this指向最后一次调用者</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  name: &apos;Byron&apos;,</span><br><span class="line">  fn : function()&#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1.fn();//&#123;name: &quot;Byron&quot;, fn: ƒ&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = obj1.fn;</span><br><span class="line">fn2();//window 因为fn是全局变量，等同于执行winow.fn2()</span><br></pre></td></tr></table></figure><p>  这么多的this的用法,你了解了吗?</p></the>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo + node.js + GitHub Page创建博客</title>
      <link href="/2018/03/24/hexo/"/>
      <url>/2018/03/24/hexo/</url>
      <content type="html"><![CDATA[<p><strong> hexo + node.js + GitHub Page创建博客：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>本文将详细介绍如何使用hexo + node.js 打造自己的轻量级博客<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>在学习前端不久，我在网上找资料，发现各位大神们都用博客记载文章，代码，或者一些教程，有些是第三方的，如简书，掘金（貌似这个是个社区），博客园等等之类的，但是也有很多通过hexo + Github Page来记录内容的，在无数次的观摩之后，我觉得我也该建立属于自己的博客了，毕竟自己的代码，自己的文章，自己心血，要好好保存，也是一个记录。</p><h2 id="第一步-需要下载node-js"><a href="#第一步-需要下载node-js" class="headerlink" title="第一步.需要下载node.js"></a>第一步.需要下载node.js</h2><ul><li><h3 id="因为Hexo是一只基于Node-js的静态博客框架，所以装node-js"><a href="#因为Hexo是一只基于Node-js的静态博客框架，所以装node-js" class="headerlink" title="因为Hexo是一只基于Node.js的静态博客框架，所以装node.js"></a>因为Hexo是一只基于Node.js的静态博客框架，所以装node.js</h3></li><li><h3 id="我们通过命令行来下载所需要的资源，方便快捷"><a href="#我们通过命令行来下载所需要的资源，方便快捷" class="headerlink" title="我们通过命令行来下载所需要的资源，方便快捷"></a>我们通过命令行来下载所需要的资源，方便快捷</h3></li><li><h3 id="具体安装过程请参阅"><a href="#具体安装过程请参阅" class="headerlink" title="具体安装过程请参阅"></a>具体安装过程请参阅</h3><p><a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">node.js安装</a></p><p><a href="https://nodejs.org/en/#download" target="_blank" rel="noopener">node.js官方地址</a></p></li></ul><h2 id="第二步-创建Github账号，创建一个仓库，用来保管我们的代码"><a href="#第二步-创建Github账号，创建一个仓库，用来保管我们的代码" class="headerlink" title="第二步.创建Github账号，创建一个仓库，用来保管我们的代码"></a>第二步.创建Github账号，创建一个仓库，用来保管我们的代码</h2><ul><li><h3 id="具体请参阅这篇文章"><a href="#具体请参阅这篇文章" class="headerlink" title="具体请参阅这篇文章"></a>具体请参阅这篇文章</h3><p><a href="https://www.jianshu.com/p/b26250a547b2" target="_blank" rel="noopener">如何创建git空仓库</a></p></li><li><h3 id="新建一个以下格式的空仓库"><a href="#新建一个以下格式的空仓库" class="headerlink" title="新建一个以下格式的空仓库"></a>新建一个以下格式的空仓库</h3><p><code>yourGitHubName.github.io</code></p></li></ul><h2 id="第三步-注册七牛云空间储存"><a href="#第三步-注册七牛云空间储存" class="headerlink" title="第三步.注册七牛云空间储存"></a>第三步.注册七牛云空间储存</h2><p>因为我们在写博客的时候，需要图片或者照片等等，还有在创建博客的时候，需要一张图片作为头像。由于github的空间资源有限，所以我们需要一个图床来放图片资源，当博客中需要用到，请先将图片资源上传到七牛图床</p><p><strong>友情提示</strong>：七牛注册需要身份证验证，所以需要身边的朋友帮忙拍2张照片，一张是本人手持身份证正面照，一张是反面，然后提交真实信息，通过支付宝帮忙验证。一般情况下，一天以后就能通过验证。</p><h2 id="第四步-开始我们的博客搭建之旅"><a href="#第四步-开始我们的博客搭建之旅" class="headerlink" title="第四步.开始我们的博客搭建之旅"></a>第四步.开始我们的博客搭建之旅</h2><ul><li><h3 id="Hexo安装-所有的安装均为命令行操作-没有git的朋友可以通过windows的cmd来操作-操作方式是一样的"><a href="#Hexo安装-所有的安装均为命令行操作-没有git的朋友可以通过windows的cmd来操作-操作方式是一样的" class="headerlink" title="Hexo安装(所有的安装均为命令行操作,没有git的朋友可以通过windows的cmd来操作,操作方式是一样的)"></a>Hexo安装(所有的安装均为命令行操作,没有git的朋友可以通过windows的cmd来操作,操作方式是一样的)</h3><p><code>npm install -g hexo-cli</code></p><p>这是通过命令行来安装hexo框架,如果你不是前端开发者,你不会理会到命令行安装东西是多么方便快捷</p></li><li><h3 id="部署本地项目"><a href="#部署本地项目" class="headerlink" title="部署本地项目"></a>部署本地项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;   //&lt;folder&gt;为你打算给Hexo项目命名的文件名</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml    //网站配置文件</span><br><span class="line">├── package.json   //应用程序的信息</span><br><span class="line">├── scaffolds      //模版文件夹</span><br><span class="line"></span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts     //你推送的博文</span><br><span class="line">└── themes         //你的主题文件夹</span><br></pre></td></tr></table></figure></li><li><h3 id="新建博文-也是通过命令行"><a href="#新建博文-也是通过命令行" class="headerlink" title="新建博文,也是通过命令行"></a>新建博文,也是通过命令行</h3><p><code>hexo new 我的第一篇文章</code></p><p>INFO  Created: F:\blog\source_posts\我的第一篇博客.md</p><p>终端会立马输出上面的这一行,意为这片博客已经建好在F盘=&gt;blog文件夹=&gt;source=&gt;_posts 目录</p></li><li><h3 id="编辑博文的工具有很多-也可以在线编辑-找到对应的网站就可以了"><a href="#编辑博文的工具有很多-也可以在线编辑-找到对应的网站就可以了" class="headerlink" title="编辑博文的工具有很多,也可以在线编辑,找到对应的网站就可以了"></a>编辑博文的工具有很多,也可以在线编辑,找到对应的网站就可以了</h3><p>不过我推荐的是vscode 或者 sublime Text3 编辑,在网上找插件,就可以在编辑的同时预览了</p></li><li><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>配置的目的是,该博客能显示你的名字,挂载到github上,<br>找到根目录_config.yml文件,找到以下字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 懒人漫游                    //网站标题</span><br><span class="line">subtitle:                         //网站描述</span><br><span class="line">description:                      //个人描述</span><br><span class="line">author:                           //作者（你的名字）</span><br><span class="line">language: zh-Hans                 //语言</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>修改最下方# Deployment中相关内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Varonia/Varonia.github.io.git   //地址修改为你自己的GitHub地址</span><br></pre></td></tr></table></figure><p>注意:原始模板信息后必须要空格,也就是冒号之后价格空格</p></li><li><h3 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   //安装 git 部署插件</span><br><span class="line">hexo clean        //清除缓存</span><br><span class="line">hexo generate     //发布到博客上</span><br><span class="line">hexo deploy       //推送到github上</span><br></pre></td></tr></table></figure></li><li><h3 id="打开博客预览"><a href="#打开博客预览" class="headerlink" title="打开博客预览"></a>打开博客预览</h3></li></ul><h2 id="第五步-更换主题"><a href="#第五步-更换主题" class="headerlink" title="第五步.更换主题"></a>第五步.更换主题</h2><ul><li><h3 id="进入hexo官网-找到主题选项-进去之后找自己喜欢的模板"><a href="#进入hexo官网-找到主题选项-进去之后找自己喜欢的模板" class="headerlink" title="进入hexo官网,找到主题选项,进去之后找自己喜欢的模板"></a>进入hexo官网,找到主题选项,进去之后找自己喜欢的模板</h3><p>每个模板都有自己对应操作介绍,但是之前还是会有差别,多试几个模板,你就会找到其中的规律,如果你是前端,你可以制作自己的风格的模板,你会发现里面的css代码,js代码,模板代码,自己或多或少的接触过,如果你不是前端,那么很抱歉,你只能再去找另外的博文教你如何操作模板的更换了.不过仔细看的话,还是蛮容易的,哈哈哈.</p></li></ul></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>几种常见的布局</title>
      <link href="/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/"/>
      <url>/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p><strong> 几种常见的布局：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>理解布局的概念<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="一-理解布局的概念"><a href="#一-理解布局的概念" class="headerlink" title="一:理解布局的概念"></a>一:理解布局的概念</h2><ul><li><h3 id="静态布局"><a href="#静态布局" class="headerlink" title="静态布局:"></a>静态布局:</h3><p>  浏览器中显示网页,通过横向或者纵向滚动条来查阅改页面内容,意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；</p></li><li><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局:"></a>弹性布局:</h3><p>  flex局部CSS3引入的一个很强大的布局方式,用来替代以前Web开发人员使用的一些复杂而易错hacks方法</p><p>  其中flex-flow是flex-direction和flex-wrap属性的简写形式,语法如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-flow:||</span><br><span class="line">flex-direction: row | row-reverse(相反) | column | colum-reverse;</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure></li><li><h3 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h3><p>  自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。你可以把自适应布局看作是静态布局的一个系列。就是说你看到的页面，里面元素的位置会变化而大小不会变化</p></li><li><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,inital-scale=1.0,maximum-scale=1.0,minimum-scale=1.0</span><br><span class="line">,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>name=”viewport” 名称=视图</li><li>width=device-width 页面宽度=设备宽度(可以理解为获取你手机的屏幕宽度)</li><li>initial-scale - 初始的缩放比例</li><li>minimum-scale - 允许用户缩放到的最小比例</li><li>maximum-scale - 允许用户缩放到的最大比例</li><li>user-scalable - 用户是否可以手动缩放</li></ul></li></ul><p>在做响应式布局的时候,必须以及一定要加上的重要头部代码.分别为不同的屏幕分辨率定义布局,同时，在每个布局中,即页面元素宽度随着窗口调整而自动适配。每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p><h2 id="二-响应式布局的步骤"><a href="#二-响应式布局的步骤" class="headerlink" title="二:响应式布局的步骤:"></a>二:响应式布局的步骤:</h2><ul><li><h3 id="布局及设置meta标签"><a href="#布局及设置meta标签" class="headerlink" title="布局及设置meta标签:"></a>布局及设置meta标签:</h3><p>  在写响应式布局之前,可以先完成非响应式布局,页面固定宽度大小,如果完成了非响应式那么我在去添加媒体查询（Media Query)和响应式代码。这种操作更容易实现响应式特性。</p><p>  当你完成当你已经完成了无响应的网站，做的第一件事是在你的 HTML 页面，粘贴下面的代码到和标签之间。这将设置屏幕按1：1的尺寸显示，在 iPhone 和其他智能手机的浏览器提供网站全视图浏览，并禁止用户缩放页面。</p><p>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot; /&gt;</code></p></li><li><h3 id="通过媒体查询来设置样式-media-query"><a href="#通过媒体查询来设置样式-media-query" class="headerlink" title="通过媒体查询来设置样式 :media query"></a>通过媒体查询来设置样式 :media query</h3><p>  media query是响应式设计的核心，它能够和浏览器进行沟通，告诉浏览器页面如何呈现，假如一个终端的分辨率小于980px，那么可以这样写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:980px)&#123;</span><br><span class="line">    #head&#123;&#125;</span><br><span class="line">    #content&#123;&#125;</span><br><span class="line">    #footer&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里面的样式会覆盖掉之前所定义的样式。</p></li></ul><ul><li><h3 id="设置多种视图宽度"><a href="#设置多种视图宽度" class="headerlink" title="设置多种视图宽度"></a>设置多种视图宽度</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**ipad**/</span><br><span class="line">@media only screen and (min-width:768px)and(max-width:1024px)&#123;&#125;</span><br><span class="line">/**iphone**/</span><br><span class="line">@media only screen and (width:320px)and (width:768px)&#123;&#125;</span><br></pre></td></tr></table></figure><p>  假如需要兼容ipad和iphone,就可以使用种写法.</p></li><li><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>  在做pc端的时候,我们习惯于写px作为像素单位,但是在移动端,在做响应式<br>  布局的时候,我们需要将字体也做成响应式的.根据屏幕的尺寸变化而变化,<br>  这个时候,我们需要用到css3新的单位,rem.<br>  rem是相对于根元素的字体大小的单位.我习惯称呼为动态rem.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:100%;&#125;</span><br><span class="line">//完成后，你可以定义响应式字体：</span><br><span class="line">@media (min-width:640px)&#123;body&#123;font-size:1rem;&#125;&#125;</span><br><span class="line">@media (min-width:960px)&#123;body&#123;font-size:1.2rem;&#125;&#125;</span><br><span class="line">@media (min-width:1200px)&#123;body&#123;font-size:1.5rem;&#125;&#125;</span><br></pre></td></tr></table></figure><p>  <strong>切记,!!!</strong>一定要重置根元素字体大小.</p></li></ul><p>下面有几个例子可以参考看看:</p><p><a href="http://js.jirengu.com/camusidemo/1/edit?html,output" target="_blank" rel="noopener">flex布局</a></p></the>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命周期中的哪些钩子函数</title>
      <link href="/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p><strong> 生命周期中的哪些钩子函数：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>生命周期的钩子函数<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="关于学习-Vue-的生命周期钩子函数"><a href="#关于学习-Vue-的生命周期钩子函数" class="headerlink" title="关于学习 Vue 的生命周期钩子函数"></a>关于学习 Vue 的生命周期钩子函数</h2><p>我们需要详细的了解,这会在写代码的时候,达到事半功倍的效果,可以帮我们很快的找出错误和解决需要,详情请见<a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener">vue</a>的这个章节</p><p>在Vue的官方文档中,给出了生命周期图示<br><img src="http://upload-images.jianshu.io/upload_images/8168023-334da70244e85c6d..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图示"></p><p>我们可以看到,这个图描述的Vue的生命周期从创建实例到销毁的过程<br>下面我们详细的说说Vue中有哪些什么周期钩子函数</p><blockquote><p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p></blockquote><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate:"></a>beforeCreate:</h4><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p><h4 id="created"><a href="#created" class="headerlink" title="created:"></a>created:</h4><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><ul><li>可以拿到数据</li><li>可以调用实例和方法</li><li>在这个生命周期钩子函数中适宜做异步请求</li></ul><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount:"></a>beforeMount:</h4><p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br>也就是说DOM还未被渲染</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted:"></a>mounted:</h4><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>DOM已经被渲染,初始数据DOM渲染完毕,可以获取DOM</p><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p><h4 id="updated"><a href="#updated" class="headerlink" title="updated:"></a>updated:</h4><p>数据更新完毕,如果对数据做统一的处理,在updated中处理<br>,如果想分别区分不同的数据更新,同时对DOM操作,用nextTick</p><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h4 id="watch-对具体某个函数变化作统一处理"><a href="#watch-对具体某个函数变化作统一处理" class="headerlink" title="watch:对具体某个函数变化作统一处理"></a>watch:对具体某个函数变化作统一处理</h4><h4 id="nextTick-处理某个数据的某一次变化"><a href="#nextTick-处理某个数据的某一次变化" class="headerlink" title="nextTick:处理某个数据的某一次变化"></a>nextTick:处理某个数据的某一次变化</h4><h4 id="created-可以获取数据-调用一部数据-调用方法"><a href="#created-可以获取数据-调用一部数据-调用方法" class="headerlink" title="created:可以获取数据,调用一部数据,调用方法"></a>created:可以获取数据,调用一部数据,调用方法</h4><p>updata在nextTick之前触发</p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
