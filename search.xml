<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/04/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/04/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong> 单例模式：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h1 id="nihao"><a href="#nihao" class="headerlink" title="nihao"></a>nihao</h1></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>动态rem</title>
      <link href="/2018/04/04/%E5%8A%A8%E6%80%81rem/"/>
      <url>/2018/04/04/%E5%8A%A8%E6%80%81rem/</url>
      <content type="html"><![CDATA[<p><strong> 动态rem：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p> rem官方解释是 font size of the root element 字面意思就是 根元素的font-size值 也就是rem是相对于元素的，比如，当html的font-size为16px时，1rem=16px。</p><p> 先看代码</p><p> <img src="https://upload-images.jianshu.io/upload_images/8168023-decadbf2c1eedaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>由于 html字体大小默认是16px，2rem是在16px的基础上，放大2倍，也就是32px,或者放大1.5倍，24px。但是在移动端，手机的屏幕是小于电脑的，如果电脑显示的16px，在手机端的话，16px就很大了，那么就需要根据实际情况在放大或缩小相应的倍数。</p><p>如果是通过css来计算，那么做移动端适配，光计算比例就得花费一大上午，于是，有了更好的方案来解决这个问题。</p><h2 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h2><p>我们可以通过sass来帮我们解决这个问题，因为sass可以写函数，在需要使用计算的宽度或者高度的时候，调用这个函数。</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@function px( $px) &#123;</span><br><span class="line">    @return $px/$designWidth*10+rem;</span><br><span class="line">&#125;</span><br><span class="line">$designWidth:640;</span><br></pre></td></tr></table></figure></p><p>具体使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@function px( $px) &#123;</span><br><span class="line">    @return $px/$designWidth*10+rem;</span><br><span class="line">&#125;</span><br><span class="line">$designWidth:640;</span><br><span class="line">.box &#123;</span><br><span class="line">    width: px(320);</span><br><span class="line">    height: px(160);</span><br><span class="line">    margin: px(40) px(40);</span><br><span class="line">    border: 1px solid #000;</span><br><span class="line">    float: left;</span><br><span class="line">    font-size: 1.2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过命令行编译<br><code>sass --watch style.scss:style.css</code></p><p>编译结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 5rem;</span><br><span class="line">  height: 2.5rem;</span><br><span class="line">  margin: 0.625rem 0.625rem;</span><br><span class="line">  border: 1px solid #000;</span><br><span class="line">  float: left;</span><br><span class="line">  font-size: 1.2em; &#125;</span><br></pre></td></tr></table></figure></p><p>这是sass计算后的结果,这样不要我们在去一个个的计算了，方便快捷。</p><p>需要注意的是：</p><h3 id="为什么设备宽度是640px？"><a href="#为什么设备宽度是640px？" class="headerlink" title="为什么设备宽度是640px？"></a>为什么设备宽度是640px？</h3><p> 对于手机屏幕来说，640px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而它的CSS逻辑像素数为320 x 568px。</p><p> 如果要切移动端页面，你可以先把效果图宽度等比例缩放到640px，很好用。</p></the>]]></content>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过call教会你this</title>
      <link href="/2018/04/03/call%EF%BC%8Capply%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2018/04/03/call%EF%BC%8Capply%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><strong> 通过call教会你this：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="通过之前《this的详解》，知道了关于this的多种调用，不同的调用，指向的不同的变量"><a href="#通过之前《this的详解》，知道了关于this的多种调用，不同的调用，指向的不同的变量" class="headerlink" title="通过之前《this的详解》，知道了关于this的多种调用，不同的调用，指向的不同的变量."></a>通过之前《this的详解》，知道了关于this的多种调用，不同的调用，指向的不同的变量.</h2><p>今天我要说的是,通过<code>call</code>方法可以明确 <code>this</code> 的指向</p></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>vue页面加载出现代码怎么办</title>
      <link href="/2018/03/29/vue%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%87%BA%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
      <url>/2018/03/29/vue%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%87%BA%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      <content type="html"><![CDATA[<p><strong> vue页面加载出现代码怎么办：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>今天碰到一个bug,那就是在写vue页面的时候,当页面在加载数据时,会出现双花括号这样的代码,很烦,很不友好,怎么办?</p><p>然后又去看官方文档,原来官方文档中有说明,而且写的很清楚,有一个指令可以帮助解决这样的问题.</p><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><ul><li>官方解释说明:</li></ul><p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 </p><ul><li>示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>不会显示，直到编译结束。</p><h2 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h2><p>由于我是编写多页面,不是单vue文件,所以,每一个页面都有自己的html文件,我直接加在head中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    [v-cloak] &#123;</span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>然后在实例中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; v-cloak&gt;</span><br><span class="line">...</span><br><span class="line">/*-- code --*/</span><br><span class="line">...</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样就解决了页面在加载过程中出现代码的小bug</p></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>三元运算符</title>
      <link href="/2018/03/25/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/25/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p><strong> 三元运算符：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>ajax</title>
      <link href="/2018/03/25/ajax/"/>
      <url>/2018/03/25/ajax/</url>
      <content type="html"><![CDATA[<p> <excerpt in="" index="" |="" 首页摘要=""><br>一种创建交互式网页应用的网页开发技术。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="ajax-是什么？有什么作用？"><a href="#ajax-是什么？有什么作用？" class="headerlink" title="ajax 是什么？有什么作用？"></a>ajax 是什么？有什么作用？</h2><ul><li><p>AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。</p></li><li><p>AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。</p></li><li><p>AJAX 是一种用于创建快速动态网页的技术。</p></li><li><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p></li><li><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。</p></li></ul><h2 id="具体来说，AJAX包括以下几个步骤。"><a href="#具体来说，AJAX包括以下几个步骤。" class="headerlink" title="具体来说，AJAX包括以下几个步骤。"></a>具体来说，AJAX包括以下几个步骤。</h2><ul><li>1.创建AJAX对象</li><li>2.发出HTTP请求</li><li>3.接收服务器传回的数据</li><li>4.更新网页数据</li></ul><p>概括起来，就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。</p><p>AJAX可以是同步请求，也可以是异步请求。但是，大多数情况下，特指异步请求。因为同步的Ajax请求，对浏览器有“堵塞效应”。</p><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><p><code>XMLHttpRequest</code>对象用来在浏览器与服务器之间传送数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ajax = new XMLHttpRequest();</span><br><span class="line">ajax.open(&apos;GET&apos;, &apos;http://www.example.com/page.php&apos;, true);</span><br><span class="line">//上面代码向指定的服务器网址，发出GET请求。sync默认是true，即为异步方式，</span><br><span class="line"></span><br><span class="line">ajax.onreadystatechange = handlerStateChange;</span><br><span class="line">//然后，AJAX指定回调函数，监听通信状态（readyState属性）的变化。</span><br></pre></td></tr></table></figure><p>一旦拿到服务器返回的数据，AJAX不会刷新整个网页，而是只更新相关部分，从而不打断用户正在做的事情。</p><p><strong>注意</strong>readyState，AJAX只能向同源网址（协议、域名、端口都相同）发出HTTP请求，如果发出跨源请求，就会报错</p><h2 id="这是XMLHttpRequest-典型用法"><a href="#这是XMLHttpRequest-典型用法" class="headerlink" title="这是XMLHttpRequest()典型用法;"></a>这是XMLHttpRequest()典型用法;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">// open方式用于指定HTTP动词、请求的网址、是否异步</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;/endpoint&apos;, true);</span><br><span class="line"></span><br><span class="line">xhr.onreadytatehange = function()&#123;</span><br><span class="line">  //通信成功状态码为4</span><br><span class="line">  if(xhr.readyState === 4)&#123;</span><br><span class="line">    if(xhr.status === 200)&#123;</span><br><span class="line">      console.log(xhr.responseText)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      console.erroe(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.onerror = function (e) &#123;</span><br><span class="line">  console.error(xhr.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 发送HTTP请求</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest实例的属性"><a href="#XMLHttpRequest实例的属性" class="headerlink" title="XMLHttpRequest实例的属性"></a>XMLHttpRequest实例的属性</h2><h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>readyState是一个只读属性，用一个整数和对应的常量，表示XMLHttpRequest请求当前所处的状态。</p><ul><li>0:对应UNSENT,表示XMLHttpRequst实例已经生成,但是open方法还没有调用.</li><li>1:d对应常量OPENED,表示send方法还没有调用,仍然可以使用setRequestHeader(),设定HTTP请求的头的信息</li><li>2:对应常量HEADERS_RECEIVED,表示send方法已经执行,b并且头部信息和状态码已经收到.</li><li>3:对应常量LOADING,表示正在接受服务器传来的body部分的数据,如果responseText属性是text或者空字符串,responseText就会包含已经收到的部分信息.</li><li>4:对应常量DONE,表示服务器数据已经完全接受,或者本次接受失败</li></ul><p>在通信过程中，每当发生状态变化的时候，readyState属性的值就会发生改变。这个值每一次变化，都会触发readyStateChange事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (ajax.readyState == 4) &#123;</span><br><span class="line">  // Handle the response.</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> // Show the &apos;Loading...&apos; message or do nothing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示,只有readstatechange == 4的时候,才算请求成功.其他的值表示还在请求当中.</p><ul><li><h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3></li></ul><p>onreadystatechange属性指向一个回调函数，当readystatechange事件发生的时候，这个回调函数就会调用，并且XMLHttpRequest实例的readyState属性也会发生变化。</p><p>另外，如果使用abort()方法，终止XMLHttpRequest请求，onreadystatechange回调函数也会被调用。</p><ul><li><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3></li></ul><p>response属性为只读，返回接收到的数据体（即body部分）。它的类型可以是ArrayBuffer、Blob、Document、JSON对象、或者一个字符串，这由XMLHttpRequest.responseType属性的值决定。</p><p>如果本次请求没有成功或者数据不完整，该属性就会等于null。</p><ul><li><h3 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h3></li></ul><p>responseType属性用来指定服务器返回数据（xhr.response）的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">”“：字符串（默认值）</span><br><span class="line">“arraybuffer”：ArrayBuffer对象</span><br><span class="line">“blob”：Blob对象</span><br><span class="line">“document”：Document对象</span><br><span class="line">“json”：JSON对象</span><br><span class="line">“text”：字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);</span><br><span class="line">xhr.responseType = &apos;blob&apos;;</span><br><span class="line"></span><br><span class="line">xhr.onload = function(e) &#123;</span><br><span class="line">  if (this.status == 200) &#123;</span><br><span class="line">    var blob = new Blob([this.response], &#123;type: &apos;image/png&apos;&#125;);</span><br><span class="line">    // 或者</span><br><span class="line">    var blob = oReq.response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><ul><li><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3></li></ul><p>status属性为只读属性，表示本次请求所得到的HTTP状态码，它是一个整数。一般来说，如果通信成功的话，这个状态码是200。</p><pre><code>200, OK，访问正常301, Moved Permanently，永久移动302, Move temporarily，暂时移动304, Not Modified，未修改307, Temporary Redirect，暂时重定向401, Unauthorized，未授权403, Forbidden，禁止访问404, Not Found，未发现指定网址500, Internal Server Error，服务器发生错误</code></pre><p>  基本上，只有2xx和304的状态码，表示服务器返回是正常状态。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (ajax.readyState == 4) &#123;</span><br><span class="line">  if ( (ajax.status &gt;= 200 &amp;&amp; ajax.status &lt; 300)</span><br><span class="line">    || (ajax.status == 304) ) &#123;</span><br><span class="line">    // Handle the response.</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Status error!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest实例的方法"><a href="#XMLHttpRequest实例的方法" class="headerlink" title="XMLHttpRequest实例的方法"></a>XMLHttpRequest实例的方法</h2><ul><li><h3 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h3><p>abort方法用来终止已经发出的HTTP请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ajax.open(&apos;GET&apos;, &apos;http://www.example.com/page.php&apos;, true);</span><br><span class="line">var ajaxAbortTimer = setTimeout(function() &#123;</span><br><span class="line">  if (ajax) &#123;</span><br><span class="line">    ajax.abort();</span><br><span class="line">    ajax = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><p>上面代码在发出5秒之后，终止一个AJAX请求。</p></li><li><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3></li></ul><p>XMLHttpRequest对象的open方法用于指定发送HTTP请求的参数，它的使用格式如下，一共可以接受五个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void open(</span><br><span class="line">   string method,</span><br><span class="line">   string url,</span><br><span class="line">   optional boolean async,</span><br><span class="line">   optional string user,</span><br><span class="line">   optional string password</span><br><span class="line">);</span><br></pre></td></tr></table></figure><pre><code>method：表示HTTP动词，比如“GET”、“POST”、“PUT”和“DELETE”。url: 表示请求发送的网址。async: 格式为布尔值，默认为true，表示请求是否为异步。如果设为false，则send()方法只有等到收到服务器返回的结果，才会有返回值。user：表示用于认证的用户名，默认为空字符串。password：表示用于认证的密码，默认为空字符串。</code></pre><p>如果对使用过open()方法的请求，再次使用这个方法，等同于调用abort()</p><ul><li><h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3></li></ul><p>send方法用于实际发出HTTP请求。如果不带参数，就表示HTTP请求只包含头信息，也就是只有一个URL，典型例子就是GET请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是POST请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax.open(&apos;GET&apos;, &apos;http://www.example.com/somepage.php?id=&apos; + encodeURIComponent(id), true);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var data = &apos;id=&apos; + encodeURIComponent(id));</span><br><span class="line">ajax.open(&apos;GET&apos;, &apos;http://www.example.com/somepage.php&apos;, true);</span><br><span class="line">ajax.send(data);</span><br></pre></td></tr></table></figure><p>上面代码中，GET请求的参数，可以作为查询字符串附加在URL后面，也可以作为send方法的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &apos;email=&apos;</span><br><span class="line">  + encodeURIComponent(email)</span><br><span class="line">  + &apos;&amp;password=&apos;</span><br><span class="line">  + encodeURIComponent(password);</span><br><span class="line">ajax.open(&apos;POST&apos;, &apos;http://www.example.com/somepage.php&apos;, true);</span><br><span class="line">ajax.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">ajax.send(data);</span><br></pre></td></tr></table></figure><p>上面是发送POST请求的例子。</p><p>如果请求是异步的（默认为异步），该方法在发出请求后会立即返回。</p><p>如果请求为同步，该方法只有等到收到服务器回应后，才会返回。</p><p>看到这里,相信对ajax有了进一步的了解,知道了ajax的作用以及用法,<br>如果你对这篇文章感兴趣,请移步阮一峰大神的博客,他那里对ajax有更加详细的介绍和使用</p><h2 id="本文摘自-阮一峰的AJAX"><a href="#本文摘自-阮一峰的AJAX" class="headerlink" title="本文摘自 阮一峰的AJAX"></a>本文摘自 <a href="http://javascript.ruanyifeng.com/bom/ajax.html#toc26" target="_blank" rel="noopener">阮一峰的AJAX</a></h2></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>怎么解析域名</title>
      <link href="/2018/03/25/%E6%80%8E%E4%B9%88%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D/"/>
      <url>/2018/03/25/%E6%80%8E%E4%B9%88%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D/</url>
      <content type="html"><![CDATA[<p><strong> 怎么解析域名：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>1、首先需要购买域名，我是在阿里云购买的，花20RMB买的是.top后缀的域名<br>2、解析域名</p><blockquote><ul><li>进入阿里云官网，登录自己的支付宝或者淘宝账号</li><li>登录成功后进入点击右上角，自己的头像，从左边的列表里找到“域名与网站”</li></ul></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/8168023-33b5805d31b9c47c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>继续点击域名</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/8168023-8a10255e4bd8de90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>点击需要解析的域名</p></blockquote><p>以下三条记录是自己添加的，一开始是空白的，按照该图添加自己的服务器ip，也就是红的部分</p><p><img src="http://upload-images.jianshu.io/upload_images/8168023-47787ee7254b61d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>3、回到桌面：开始&gt;运行&gt;cmd,输入<code>ping 域名</code><br>    看到如下显示，说明解析成功</p><p><img src="http://upload-images.jianshu.io/upload_images/8168023-242c11239c80fed3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当显示 time out就说明解析不成功</p></the>]]></content>
      
      
        <tags>
            
            <tag> 计算机知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单了解webpack和npm</title>
      <link href="/2018/03/25/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3webpack%E5%92%8Cnpm/"/>
      <url>/2018/03/25/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3webpack%E5%92%8Cnpm/</url>
      <content type="html"><![CDATA[<p><strong> 简单了解webpack和npm：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="如何全局安装一个-node-应用"><a href="#如何全局安装一个-node-应用" class="headerlink" title="如何全局安装一个 node 应用?"></a>如何全局安装一个 node 应用?</h2><p><code>npm install -g</code></p><h2 id="package-json-有什么作用？"><a href="#package-json-有什么作用？" class="headerlink" title="package.json 有什么作用？"></a>package.json 有什么作用？</h2><p>npm上发布包时，需要<code>npm init</code>生成package.json文件<br>package.json中的信息来描述这个包,并提供包所需要的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;gulp-use&quot;,//发布npm包的时候需要的，表示npm包的名字</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,//包的版本号</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,//对于这个包的简单描述</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,//入口文件</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;//</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],// 关键字</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,//作者</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,//</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;,//所依赖的其他包的版本号</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="npm-install-–save-app-与-npm-install-–save-dev-app有什么区别"><a href="#npm-install-–save-app-与-npm-install-–save-dev-app有什么区别" class="headerlink" title="npm install –save app 与 npm install –save-dev app有什么区别?"></a>npm install –save app 与 npm install –save-dev app有什么区别?</h2><ul><li><p><code>npm install --save app</code>: 保存需要加载的依赖的信息到package.json里面,该模块使用时，该依赖被调用</p></li><li><p><code>npm install --save-dev app</code>: 开发测试时使用的依赖，当需要测试时，可以调用该依赖</p></li></ul><h4 id="node-modules的查找路径是怎样的"><a href="#node-modules的查找路径是怎样的" class="headerlink" title="node_modules的查找路径是怎样的?"></a>node_modules的查找路径是怎样的?</h4><p>该模块的同级目录下查找nodule_modules =&gt; if(没有) 向上一级查找 =&gt; if(没有) 再向上一级 …=&gt; 直到找到根目录下</p><h4 id="webpack是什么？和其他同类型工具比有什么优势？"><a href="#webpack是什么？和其他同类型工具比有什么优势？" class="headerlink" title="webpack是什么？和其他同类型工具比有什么优势？"></a>webpack是什么？和其他同类型工具比有什么优势？</h4><p>市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。</p><p>这些已有的模块化工具并不能很好的完成如下的目标：</p><ul><li><p>将依赖树拆分成按需加载的块</p></li><li><p>初始化加载的耗时尽量少</p></li><li><p>各种静态资源都可以视作模块</p></li><li><p>将第三方库整合成模块的能力</p></li><li><p>可以自定义打包逻辑的能力</p></li><li><p>适合大项目，无论是单页还是多页的 Web 应用</p><h4 id="和其他同类型工具比有什么优势？"><a href="#和其他同类型工具比有什么优势？" class="headerlink" title="和其他同类型工具比有什么优势？"></a>和其他同类型工具比有什么优势？</h4></li></ul><p>webpack的优势：</p><ul><li>1.代码拆分</li></ul><p>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p><ul><li>2.Loader</li></ul><p>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p><ul><li>3.智能解析</li></ul><p>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。</p><ul><li>4.插件系统</li></ul><p>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</p><ul><li>5.快速运行</li></ul><p>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p><h2 id="npm-scripts是什么？如何使用？"><a href="#npm-scripts是什么？如何使用？" class="headerlink" title="npm scripts是什么？如何使用？"></a>npm scripts是什么？如何使用？</h2><p>npm 允许在package.json文件里面，使用scripts字段定义脚本命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node ./bin/www&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;webpack --config ./src/webpack.config.js&quot;,</span><br><span class="line">    &quot;watch&quot;: &quot;onchange \&quot;src/**/*.js\&quot;  \&quot;src/**/*.less\&quot; -- npm run webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>输入<br><code>npm run webpack</code><br> 或者<br> <code>npm run watch</code><br> 就可以执行对应的脚本<br>但是比如start 或 bulid 等，可以直接<code>npm start</code></p></the>]]></content>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于js数据类型</title>
      <link href="/2018/03/25/%E5%85%B3%E4%BA%8Ejs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/25/%E5%85%B3%E4%BA%8Ejs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><strong> 关于js数据类型：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>本文介绍关于JavaScript数据类型的相关知识<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>  JavaScript语言的每一个值，都属于某一种数据类型。JavaScript的数据类型，共有六种。</p><p>  数值（number）：整数和小数（比如1和3.14）</p><p>  字符串（string）：字符组成的文本（比如”Hello World”）</p><p>  布尔值（boolean）：true（真）和false（假）两个特定值</p><p>  undefined：表示“未定义”或不存在，即此处目前没有任何值</p><p>  null：表示空缺，即此处应该有一个值，但目前为空</p><p>  对象（object）：各种值组成的集合</p><p><strong>但是在最新的 ECMAScript 标准中定义了第七种数据类型</strong></p><p>  Symbol (ECMAScript 6 新定义)</p><h2 id="其中又分为简单类型和复杂类型"><a href="#其中又分为简单类型和复杂类型" class="headerlink" title="其中又分为简单类型和复杂类型"></a>其中又分为简单类型和复杂类型</h2><ul><li>数值(number)、字符串(string)、布尔值(boolean),以及后定义的Symbol 称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</li><li>将对象称为复杂类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器.如数组,函数等等</li><li>至于undefined和null，一般将它们看成两个特殊值。</li></ul><p>JavaScript有三种方法，可以确定一个值到底是什么类型。</p><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li><p>Object.prototype.toString 方法</p><p>typeof 运算符可以返回一个值的数据类型，可能有以下结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof 123 // &quot;number&quot;</span><br><span class="line">typeof &apos;123&apos; // &quot;string&quot;</span><br><span class="line">typeof false // &quot;boolean&quot;</span><br></pre></td></tr></table></figure><p>原始类型:数值、字符串、布尔值分别返回number、string、boolean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f</span><br><span class="line">// &quot;function&quot;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">typeof obj //object</span><br></pre></td></tr></table></figure><p>函数,返回的结果是function</p><p>对象,返回的结果是object</p></li></ul><h2 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h2><p>对于null和undefined，可以大致可以像下面这样理解。</p><p>null表示空值，即该处的值现在为空。典型用法是：</p><p>作为函数的参数，表示该函数的参数是一个没有任何内容的对象。<br>作为对象原型链的终点。<br>undefined表示不存在值，就是此处目前不存在任何值。典型用法是：</p><p>变量被声明了，但没有赋值时，就等于undefined。<br>调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>对象没有赋值的属性，该属性的值为undefined。<br>函数没有返回值时，默认返回undefined。</p><p>举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">function f(x)&#123;console.log(x)&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">var x = f();</span><br><span class="line">x // undefined</span><br></pre></td></tr></table></figure></p><ul><li><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><ul><li>两元逻辑运算符： &amp;&amp; (And)，|| (Or)</li><li>前置逻辑运算符： ! (Not)</li><li>相等运算符：===，!==，==，!=</li><li>比较运算符：&gt;，&gt;=，&lt;，&lt;=</li></ul></li><li><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript的数字类型和其它语言有所不同，没有整型和浮点数的区别，统一都是Number类型，可以表示十进制、八进制、十六进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 10; //十进制</span><br><span class="line">var b = 073; //八进制</span><br><span class="line">vat c = 0xf3; //十六进制</span><br></pre></td></tr></table></figure></li><li><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>String是Unicode字符组成的序列，俗称字符串，可以用双引号或者单引号表示，没有区别，匹配即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;;</span><br><span class="line">var str2 = &quot;zhouyi&quot;;</span><br><span class="line">var str3 = &apos;hello &quot;world&quot; &apos;;</span><br></pre></td></tr></table></figure></li><li><h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><p>对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。key我们称为对象的属性，value可以是任何JavaScript类型，甚至可以是对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">name: &apos;jirengu&apos;,</span><br><span class="line">age: 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>object的属性读取有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.name;</span><br><span class="line">obj[&apos;name&apos;];</span><br></pre></td></tr></table></figure></li><li><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = undefined;</span><br><span class="line">var a = null;</span><br></pre></td></tr></table></figure><p>上面代码中，a变量分别被赋值为’undefined’和’null’，这两种写法的效果几乎等价。</p><p>在’if’语句中，它们都会被自动转为’false’，相等运算符（’==’）甚至直接报告两者相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!undefined) &#123;</span><br><span class="line">  console.log(&apos;undefined is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// undefined is false</span><br><span class="line"></span><br><span class="line">if (!null) &#123;</span><br><span class="line">  console.log(&apos;null is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// null is false</span><br><span class="line"></span><br><span class="line">undefined == null</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>  上面代码说明，两者的行为是何等相似！Google公司开发的JavaScript语言的替代品Dart语言，就明确规定只有null，没有undefined！</p><p>  既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。</p><p>  1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(null) // 0</span><br><span class="line">5 + null // 5</span><br></pre></td></tr></table></figure><p>但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。</p><p>首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型和合成类型两大类，Brendan Eich觉得表示”无”的值最好不是对象。</p><p>其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。</p><p>因此，Brendan Eich又设计了一个undefined。他是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(undefined) // NaN</span><br><span class="line">5 + undefined // NaN</span><br></pre></td></tr></table></figure><p>但是，这样的区分在实践中很快就被证明不可行。目前null和’undefined’基本是同义的，只有一些细微的差别。<br>‘null’的特殊之处在于，JavaScript把它包含在对象类型（object）之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>上面代码表示，查询null的类型，JavaScript返回object（对象）。</p><p>这并不是说null的数据类型就是对象，而是JavaScript早期部署中的一个约定俗成，其实不完全正确，后来再想改已经太晚了，会破坏现存代码，所以一直保留至今。</p><p>注意，JavaScript的标识名区分大小写，所以undefined和null不同于Undefined和Null（或者其他仅仅大小写不同的词形），后者只是普通的变量名。<br>Boolean<br>布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><p>两元逻辑运算符： &amp;&amp; (And)，|| (Or)</p><p>前置逻辑运算符： ! (Not)</p><p>相等运算符：===，!==，==，!=</p><p>比较运算符：&gt;，&gt;=，&lt;，&lt;=</p><p>JavaScript有三种方法，可以确定一个值到底是什么类型。</p><ul><li><p>typeof运算符</p></li><li><p>instanceof运算符 </p></li><li><p>Object.prototype.toString方法</p></li></ul></li></ul></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>this详解</title>
      <link href="/2018/03/24/this%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/24/this%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong> this详解：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>我们来谈谈this吧<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>this,我相信很多JavaScript初学者都搞不懂this,包括我自己也是,很懵逼</p><h2 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h2><p>  由于运行期绑定的特性，JavaScript 中的 this 含义非常多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象</p><h2 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>  在函数直接调用时,this绑定到全局对象上.在浏览器,window就是该全局对象</p><p>  我们来看个例子<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p> <img src="https://upload-images.jianshu.io/upload_images/8168023-5f7f52173d98e75b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  在开发者工具中我们可以清楚的看到,第一个this是window对象,因为做了标记,第二个this也就是fn()调用后,打印出的也是window对象,所以充分说明,在函数直接调用时,window就是该全局对象</p><p>  还有,我们需要走出一个误区,这个误区就是,<strong>函数里的thisb不代表函数本身</strong><br>  下面继续看例子<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line">function fn1()&#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn()//100</span><br></pre></td></tr></table></figure></p><p>  结果打印出的是100<br>  也就是说,函数fn1中声明了a = 1,但是调用函数,里面打印出的值是外面的那个a,也就是说,fn1()里的this指向的还是全局对象,而不是它内部申明的那个a</p><p>  再来一个例子我们看看这个如果全局没有申明a,会是怎样</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn2()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8168023-466adecd063e64b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>结果是undefined,因为在全局上找不到a</p><p>注意,这次打印的是a,而不是直接打印this,所以结果不是window,因为全局对象上没有a</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>  看完外部调用,我们在来看看内部调用this,又将会打印出什么</p><p>  话不多说,无码无真相</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;</span><br><span class="line">  function children()&#123;</span><br><span class="line">    console.loh(this)</span><br><span class="line">  &#125;</span><br><span class="line">  children()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent()</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-5fc10c6435f91ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  你看,还是打印出的是this,为什么?</p><p>  首先会在函数内部找this，发现子函数里找不到this，那就去父函数找，还是找不到，最后就去父函数的外面也就是全局下找this，所以打印出的是window</p><p>  结论 : 函数嵌套产生的内部函数的this不是其父函数，仍然是全局变量.</p><h2 id="setTimeout、setInterval"><a href="#setTimeout、setInterval" class="headerlink" title="setTimeout、setInterval"></a>setTimeout、setInterval</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-a6f0737747b8a40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image.png"></p><p>  第一个this是绑定事件的这个元素，第二个this代表的全局对象window,如图所示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">    var me = this</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(me);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-fe8f46533b216f15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473" alt="image.png"></p><p>  如果在函数里申明了<code>var self = this</code>，那么第二个this就变掉了，相当于把第一个this代表的元素保存起来了，我们直接来看代码。如果看的有点绕的话，可以这么想，我可以不用_this，可以用me、self来代替_this，效果一样.</p><h2 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h2><p>  所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p><p>  new 运算符接受一个函数 F 及其参数：new F(arguments…)。这一过程分为三步：</p><ul><li><p>创建类的实例。这步是把一个空的对象的 <strong> </strong>proto__ __ 属性设置为 F.prototype 。</p><ul><li>初始化实例。函数 F 被传入参数并调用，关键字 this 被设定为该实例。</li><li>返回实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Byron&apos;);</span><br><span class="line">var p2 = new Person(&apos;Casper&apos;);</span><br><span class="line">var p3 = new Person(&apos;Vincent&apos;);</span><br><span class="line"></span><br><span class="line">p1.printName();</span><br><span class="line">p2.printName();</span><br><span class="line">p3.printName();</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/8168023-9b56f8ee60341655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>p1.printName();这句话执行的时候，先执行p1 = new Person(‘Byron’)，然后在new的时候，做了三件事，</p><ul><li><p>1、创建新的空对象</p></li><li><p>2、然后是把这个空的对象的 <strong>proto</strong> 属性设置为 Person.prototype </p></li><li><p>3、执行函数Person，遇到this，就认为this是刚才创建的对象，给它添加一个属性name，而这个属性的值就是函数Person的name</p></li></ul><p>执行完成之后，把新对象return出来赋值给p1<br>这样就可以通过p1的方式去用了</p><h2 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h2><p>  在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象，简单的来说，就是谁调用这个函数，这个函数指的就是谁（这个this就代表谁）。</p><p>  如：Object1.fn()，this指的就是Object1，<br>  假如：Object1.Object2.Object3.fn(),this指的就是Object3，<br>  <strong>this指向最后一次调用者</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  name: &apos;Byron&apos;,</span><br><span class="line">  fn : function()&#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1.fn();//&#123;name: &quot;Byron&quot;, fn: ƒ&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = obj1.fn;</span><br><span class="line">fn2();//window 因为fn是全局变量，等同于执行winow.fn2()</span><br></pre></td></tr></table></figure><p>  这么多的this的用法,你了解了吗?</p></the>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo + node.js + GitHub Page创建博客</title>
      <link href="/2018/03/24/hexo/"/>
      <url>/2018/03/24/hexo/</url>
      <content type="html"><![CDATA[<p><strong> hexo + node.js + GitHub Page创建博客：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>本文将详细介绍如何使用hexo + node.js 打造自己的轻量级博客<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>在学习前端不久，我在网上找资料，发现各位大神们都用博客记载文章，代码，或者一些教程，有些是第三方的，如简书，掘金（貌似这个是个社区），博客园等等之类的，但是也有很多通过hexo + Github Page来记录内容的，在无数次的观摩之后，我觉得我也该建立属于自己的博客了，毕竟自己的代码，自己的文章，自己心血，要好好保存，也是一个记录。</p><h2 id="第一步-需要下载node-js"><a href="#第一步-需要下载node-js" class="headerlink" title="第一步.需要下载node.js"></a>第一步.需要下载node.js</h2><ul><li><h3 id="因为Hexo是一只基于Node-js的静态博客框架，所以装node-js"><a href="#因为Hexo是一只基于Node-js的静态博客框架，所以装node-js" class="headerlink" title="因为Hexo是一只基于Node.js的静态博客框架，所以装node.js"></a>因为Hexo是一只基于Node.js的静态博客框架，所以装node.js</h3></li><li><h3 id="我们通过命令行来下载所需要的资源，方便快捷"><a href="#我们通过命令行来下载所需要的资源，方便快捷" class="headerlink" title="我们通过命令行来下载所需要的资源，方便快捷"></a>我们通过命令行来下载所需要的资源，方便快捷</h3></li><li><h3 id="具体安装过程请参阅"><a href="#具体安装过程请参阅" class="headerlink" title="具体安装过程请参阅"></a>具体安装过程请参阅</h3><p><a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">node.js安装</a></p><p><a href="https://nodejs.org/en/#download" target="_blank" rel="noopener">node.js官方地址</a></p></li></ul><h2 id="第二步-创建Github账号，创建一个仓库，用来保管我们的代码"><a href="#第二步-创建Github账号，创建一个仓库，用来保管我们的代码" class="headerlink" title="第二步.创建Github账号，创建一个仓库，用来保管我们的代码"></a>第二步.创建Github账号，创建一个仓库，用来保管我们的代码</h2><ul><li><h3 id="具体请参阅这篇文章"><a href="#具体请参阅这篇文章" class="headerlink" title="具体请参阅这篇文章"></a>具体请参阅这篇文章</h3><p><a href="https://www.jianshu.com/p/b26250a547b2" target="_blank" rel="noopener">如何创建git空仓库</a></p></li><li><h3 id="新建一个以下格式的空仓库"><a href="#新建一个以下格式的空仓库" class="headerlink" title="新建一个以下格式的空仓库"></a>新建一个以下格式的空仓库</h3><p><code>yourGitHubName.github.io</code></p></li></ul><h2 id="第三步-注册七牛云空间储存"><a href="#第三步-注册七牛云空间储存" class="headerlink" title="第三步.注册七牛云空间储存"></a>第三步.注册七牛云空间储存</h2><p>因为我们在写博客的时候，需要图片或者照片等等，还有在创建博客的时候，需要一张图片作为头像。由于github的空间资源有限，所以我们需要一个图床来放图片资源，当博客中需要用到，请先将图片资源上传到七牛图床</p><p><strong>友情提示</strong>：七牛注册需要身份证验证，所以需要身边的朋友帮忙拍2张照片，一张是本人手持身份证正面照，一张是反面，然后提交真实信息，通过支付宝帮忙验证。一般情况下，一天以后就能通过验证。</p><h2 id="第四步-开始我们的博客搭建之旅"><a href="#第四步-开始我们的博客搭建之旅" class="headerlink" title="第四步.开始我们的博客搭建之旅"></a>第四步.开始我们的博客搭建之旅</h2><ul><li><h3 id="Hexo安装-所有的安装均为命令行操作-没有git的朋友可以通过windows的cmd来操作-操作方式是一样的"><a href="#Hexo安装-所有的安装均为命令行操作-没有git的朋友可以通过windows的cmd来操作-操作方式是一样的" class="headerlink" title="Hexo安装(所有的安装均为命令行操作,没有git的朋友可以通过windows的cmd来操作,操作方式是一样的)"></a>Hexo安装(所有的安装均为命令行操作,没有git的朋友可以通过windows的cmd来操作,操作方式是一样的)</h3><p><code>npm install -g hexo-cli</code></p><p>这是通过命令行来安装hexo框架,如果你不是前端开发者,你不会理会到命令行安装东西是多么方便快捷</p></li><li><h3 id="部署本地项目"><a href="#部署本地项目" class="headerlink" title="部署本地项目"></a>部署本地项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;   //&lt;folder&gt;为你打算给Hexo项目命名的文件名</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml    //网站配置文件</span><br><span class="line">├── package.json   //应用程序的信息</span><br><span class="line">├── scaffolds      //模版文件夹</span><br><span class="line"></span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts     //你推送的博文</span><br><span class="line">└── themes         //你的主题文件夹</span><br></pre></td></tr></table></figure></li><li><h3 id="新建博文-也是通过命令行"><a href="#新建博文-也是通过命令行" class="headerlink" title="新建博文,也是通过命令行"></a>新建博文,也是通过命令行</h3><p><code>hexo new 我的第一篇文章</code></p><p>INFO  Created: F:\blog\source_posts\我的第一篇博客.md</p><p>终端会立马输出上面的这一行,意为这片博客已经建好在F盘=&gt;blog文件夹=&gt;source=&gt;_posts 目录</p></li><li><h3 id="编辑博文的工具有很多-也可以在线编辑-找到对应的网站就可以了"><a href="#编辑博文的工具有很多-也可以在线编辑-找到对应的网站就可以了" class="headerlink" title="编辑博文的工具有很多,也可以在线编辑,找到对应的网站就可以了"></a>编辑博文的工具有很多,也可以在线编辑,找到对应的网站就可以了</h3><p>不过我推荐的是vscode 或者 sublime Text3 编辑,在网上找插件,就可以在编辑的同时预览了</p></li><li><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>配置的目的是,该博客能显示你的名字,挂载到github上,<br>找到根目录_config.yml文件,找到以下字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 懒人漫游                    //网站标题</span><br><span class="line">subtitle:                         //网站描述</span><br><span class="line">description:                      //个人描述</span><br><span class="line">author:                           //作者（你的名字）</span><br><span class="line">language: zh-Hans                 //语言</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>修改最下方# Deployment中相关内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Varonia/Varonia.github.io.git   //地址修改为你自己的GitHub地址</span><br></pre></td></tr></table></figure><p>注意:原始模板信息后必须要空格,也就是冒号之后价格空格</p></li><li><h3 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   //安装 git 部署插件</span><br><span class="line">hexo clean        //清除缓存</span><br><span class="line">hexo generate     //发布到博客上</span><br><span class="line">hexo deploy       //推送到github上</span><br></pre></td></tr></table></figure></li><li><h3 id="打开博客预览"><a href="#打开博客预览" class="headerlink" title="打开博客预览"></a>打开博客预览</h3></li></ul><h2 id="第五步-更换主题"><a href="#第五步-更换主题" class="headerlink" title="第五步.更换主题"></a>第五步.更换主题</h2><ul><li><h3 id="进入hexo官网-找到主题选项-进去之后找自己喜欢的模板"><a href="#进入hexo官网-找到主题选项-进去之后找自己喜欢的模板" class="headerlink" title="进入hexo官网,找到主题选项,进去之后找自己喜欢的模板"></a>进入hexo官网,找到主题选项,进去之后找自己喜欢的模板</h3><p>每个模板都有自己对应操作介绍,但是之前还是会有差别,多试几个模板,你就会找到其中的规律,如果你是前端,你可以制作自己的风格的模板,你会发现里面的css代码,js代码,模板代码,自己或多或少的接触过,如果你不是前端,那么很抱歉,你只能再去找另外的博文教你如何操作模板的更换了.不过仔细看的话,还是蛮容易的,哈哈哈.</p></li></ul></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>几种常见的布局</title>
      <link href="/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/"/>
      <url>/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p><strong> 几种常见的布局：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>理解布局的概念<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="一-理解布局的概念"><a href="#一-理解布局的概念" class="headerlink" title="一:理解布局的概念"></a>一:理解布局的概念</h2><ul><li><h3 id="静态布局"><a href="#静态布局" class="headerlink" title="静态布局:"></a>静态布局:</h3><p>  浏览器中显示网页,通过横向或者纵向滚动条来查阅改页面内容,意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；</p></li><li><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局:"></a>弹性布局:</h3><p>  flex局部CSS3引入的一个很强大的布局方式,用来替代以前Web开发人员使用的一些复杂而易错hacks方法</p><p>  其中flex-flow是flex-direction和flex-wrap属性的简写形式,语法如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-flow:||</span><br><span class="line">flex-direction: row | row-reverse(相反) | column | colum-reverse;</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure></li><li><h3 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h3><p>  自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。你可以把自适应布局看作是静态布局的一个系列。就是说你看到的页面，里面元素的位置会变化而大小不会变化</p></li><li><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,inital-scale=1.0,maximum-scale=1.0,minimum-scale=1.0</span><br><span class="line">,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>name=”viewport” 名称=视图</li><li>width=device-width 页面宽度=设备宽度(可以理解为获取你手机的屏幕宽度)</li><li>initial-scale - 初始的缩放比例</li><li>minimum-scale - 允许用户缩放到的最小比例</li><li>maximum-scale - 允许用户缩放到的最大比例</li><li>user-scalable - 用户是否可以手动缩放</li></ul></li></ul><p>在做响应式布局的时候,必须以及一定要加上的重要头部代码.分别为不同的屏幕分辨率定义布局,同时，在每个布局中,即页面元素宽度随着窗口调整而自动适配。每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p><h2 id="二-响应式布局的步骤"><a href="#二-响应式布局的步骤" class="headerlink" title="二:响应式布局的步骤:"></a>二:响应式布局的步骤:</h2><ul><li><h3 id="布局及设置meta标签"><a href="#布局及设置meta标签" class="headerlink" title="布局及设置meta标签:"></a>布局及设置meta标签:</h3><p>  在写响应式布局之前,可以先完成非响应式布局,页面固定宽度大小,如果完成了非响应式那么我在去添加媒体查询（Media Query)和响应式代码。这种操作更容易实现响应式特性。</p><p>  当你完成当你已经完成了无响应的网站，做的第一件事是在你的 HTML 页面，粘贴下面的代码到和标签之间。这将设置屏幕按1：1的尺寸显示，在 iPhone 和其他智能手机的浏览器提供网站全视图浏览，并禁止用户缩放页面。</p><p>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot; /&gt;</code></p></li><li><h3 id="通过媒体查询来设置样式-media-query"><a href="#通过媒体查询来设置样式-media-query" class="headerlink" title="通过媒体查询来设置样式 :media query"></a>通过媒体查询来设置样式 :media query</h3><p>  media query是响应式设计的核心，它能够和浏览器进行沟通，告诉浏览器页面如何呈现，假如一个终端的分辨率小于980px，那么可以这样写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:980px)&#123;</span><br><span class="line">    #head&#123;&#125;</span><br><span class="line">    #content&#123;&#125;</span><br><span class="line">    #footer&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里面的样式会覆盖掉之前所定义的样式。</p></li></ul><ul><li><h3 id="设置多种视图宽度"><a href="#设置多种视图宽度" class="headerlink" title="设置多种视图宽度"></a>设置多种视图宽度</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**ipad**/</span><br><span class="line">@media only screen and (min-width:768px)and(max-width:1024px)&#123;&#125;</span><br><span class="line">/**iphone**/</span><br><span class="line">@media only screen and (width:320px)and (width:768px)&#123;&#125;</span><br></pre></td></tr></table></figure><p>  假如需要兼容ipad和iphone,就可以使用种写法.</p></li><li><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>  在做pc端的时候,我们习惯于写px作为像素单位,但是在移动端,在做响应式<br>  布局的时候,我们需要将字体也做成响应式的.根据屏幕的尺寸变化而变化,<br>  这个时候,我们需要用到css3新的单位,rem.<br>  rem是相对于根元素的字体大小的单位.我习惯称呼为动态rem.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:100%;&#125;</span><br><span class="line">//完成后，你可以定义响应式字体：</span><br><span class="line">@media (min-width:640px)&#123;body&#123;font-size:1rem;&#125;&#125;</span><br><span class="line">@media (min-width:960px)&#123;body&#123;font-size:1.2rem;&#125;&#125;</span><br><span class="line">@media (min-width:1200px)&#123;body&#123;font-size:1.5rem;&#125;&#125;</span><br></pre></td></tr></table></figure><p>  <strong>切记,!!!</strong>一定要重置根元素字体大小.</p></li></ul><p>下面有几个例子可以参考看看:</p><p><a href="http://js.jirengu.com/camusidemo/1/edit?html,output" target="_blank" rel="noopener">flex布局</a></p></the>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命周期中的哪些钩子函数</title>
      <link href="/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p><strong> 生命周期中的哪些钩子函数：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>生命周期的钩子函数<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="关于学习-Vue-的生命周期钩子函数"><a href="#关于学习-Vue-的生命周期钩子函数" class="headerlink" title="关于学习 Vue 的生命周期钩子函数"></a>关于学习 Vue 的生命周期钩子函数</h2><p>我们需要详细的了解,这会在写代码的时候,达到事半功倍的效果,可以帮我们很快的找出错误和解决需要,详情请见<a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener">vue</a>的这个章节</p><p>在Vue的官方文档中,给出了生命周期图示<br><img src="http://upload-images.jianshu.io/upload_images/8168023-334da70244e85c6d..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图示"></p><p>我们可以看到,这个图描述的Vue的生命周期从创建实例到销毁的过程<br>下面我们详细的说说Vue中有哪些什么周期钩子函数</p><blockquote><p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p></blockquote><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate:"></a>beforeCreate:</h4><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p><h4 id="created"><a href="#created" class="headerlink" title="created:"></a>created:</h4><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><ul><li>可以拿到数据</li><li>可以调用实例和方法</li><li>在这个生命周期钩子函数中适宜做异步请求</li></ul><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount:"></a>beforeMount:</h4><p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br>也就是说DOM还未被渲染</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted:"></a>mounted:</h4><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>DOM已经被渲染,初始数据DOM渲染完毕,可以获取DOM</p><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p><h4 id="updated"><a href="#updated" class="headerlink" title="updated:"></a>updated:</h4><p>数据更新完毕,如果对数据做统一的处理,在updated中处理<br>,如果想分别区分不同的数据更新,同时对DOM操作,用nextTick</p><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h4 id="watch-对具体某个函数变化作统一处理"><a href="#watch-对具体某个函数变化作统一处理" class="headerlink" title="watch:对具体某个函数变化作统一处理"></a>watch:对具体某个函数变化作统一处理</h4><h4 id="nextTick-处理某个数据的某一次变化"><a href="#nextTick-处理某个数据的某一次变化" class="headerlink" title="nextTick:处理某个数据的某一次变化"></a>nextTick:处理某个数据的某一次变化</h4><h4 id="created-可以获取数据-调用一部数据-调用方法"><a href="#created-可以获取数据-调用一部数据-调用方法" class="headerlink" title="created:可以获取数据,调用一部数据,调用方法"></a>created:可以获取数据,调用一部数据,调用方法</h4><p>updata在nextTick之前触发</p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
