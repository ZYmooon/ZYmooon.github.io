<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>this详解</title>
      <link href="/2018/03/24/this%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/24/this%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong> this详解：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>我们来谈谈this吧<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>this,我相信很多JavaScript初学者都搞不懂this,包括我自己也是,很懵逼</p><h2 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h2><p>  由于运行期绑定的特性，JavaScript 中的 this 含义非常多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象</p><h2 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>  在函数直接调用时,this绑定到全局对象上.在浏览器,window就是该全局对象</p><p>  我们来看个例子<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p> <img src="https://upload-images.jianshu.io/upload_images/8168023-5f7f52173d98e75b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  在开发者工具中我们可以清楚的看到,第一个this是window对象,因为做了标记,第二个this也就是fn()调用后,打印出的也是window对象,所以充分说明,在函数直接调用时,window就是该全局对象</p><p>  还有,我们需要走出一个误区,这个误区就是,<strong>函数里的thisb不代表函数本身</strong><br>  下面继续看例子<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line">function fn1()&#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn()//100</span><br></pre></td></tr></table></figure></p><p>  结果打印出的是100<br>  也就是说,函数fn1中声明了a = 1,但是调用函数,里面打印出的值是外面的那个a,也就是说,fn1()里的this指向的还是全局对象,而不是它内部申明的那个a</p><p>  再来一个例子我们看看这个如果全局没有申明a,会是怎样</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn2()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8168023-466adecd063e64b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>结果是undefined,因为在全局上找不到a</p><p>注意,这次打印的是a,而不是直接打印this,所以结果不是window,因为全局对象上没有a</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>  看完外部调用,我们在来看看内部调用this,又将会打印出什么</p><p>  话不多说,无码无真相</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;</span><br><span class="line">  function children()&#123;</span><br><span class="line">    console.loh(this)</span><br><span class="line">  &#125;</span><br><span class="line">  children()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent()</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-5fc10c6435f91ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>  你看,还是打印出的是this,为什么?</p><p>  首先会在函数内部找this，发现子函数里找不到this，那就去父函数找，还是找不到，最后就去父函数的外面也就是全局下找this，所以打印出的是window</p><p>  结论 : 函数嵌套产生的内部函数的this不是其父函数，仍然是全局变量.</p><h2 id="setTimeout、setInterval"><a href="#setTimeout、setInterval" class="headerlink" title="setTimeout、setInterval"></a>setTimeout、setInterval</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-a6f0737747b8a40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image.png"></p><p>  第一个this是绑定事件的这个元素，第二个this代表的全局对象window,如图所示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">    var me = this</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(me);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure><p>  <img src="https://upload-images.jianshu.io/upload_images/8168023-fe8f46533b216f15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473" alt="image.png"></p><p>  如果在函数里申明了<code>var self = this</code>，那么第二个this就变掉了，相当于把第一个this代表的元素保存起来了，我们直接来看代码。如果看的有点绕的话，可以这么想，我可以不用_this，可以用me、self来代替_this，效果一样.</p><h2 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h2><p>  所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象</p><p>  new 运算符接受一个函数 F 及其参数：new F(arguments…)。这一过程分为三步：</p><ul><li><p>创建类的实例。这步是把一个空的对象的 __proto__ 属性设置为 F.prototype 。</p><ul><li>初始化实例。函数 F 被传入参数并调用，关键字 this 被设定为该实例。</li><li>返回实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Byron&apos;);</span><br><span class="line">var p2 = new Person(&apos;Casper&apos;);</span><br><span class="line">var p3 = new Person(&apos;Vincent&apos;);</span><br><span class="line"></span><br><span class="line">p1.printName();</span><br><span class="line">p2.printName();</span><br><span class="line">p3.printName();</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/8168023-9b56f8ee60341655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>p1.printName();这句话执行的时候，先执行p1 = new Person(‘Byron’)，然后在new的时候，做了三件事，</p><ul><li><p>1、创建新的空对象</p></li><li><p>2、然后是把这个空的对象的 <strong>proto</strong> 属性设置为 Person.prototype </p></li><li><p>3、执行函数Person，遇到this，就认为this是刚才创建的对象，给它添加一个属性name，而这个属性的值就是函数Person的name</p></li></ul><p>执行完成之后，把新对象return出来赋值给p1<br>这样就可以通过p1的方式去用了</p><h2 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h2><p>  在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象，简单的来说，就是谁调用这个函数，这个函数指的就是谁（这个this就代表谁）。</p><p>  如：Object1.fn()，this指的就是Object1，<br>  假如：Object1.Object2.Object3.fn(),this指的就是Object3，<br>  <strong>this指向最后一次调用者</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  name: &apos;Byron&apos;,</span><br><span class="line">  fn : function()&#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1.fn();//&#123;name: &quot;Byron&quot;, fn: ƒ&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = obj1.fn;</span><br><span class="line">fn2();//window 因为fn是全局变量，等同于执行winow.fn2()</span><br></pre></td></tr></table></figure><p>  这么多的this的用法,你了解了吗?</p></the>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo + node.js + GitHub Page创建博客</title>
      <link href="/2018/03/24/texte/"/>
      <url>/2018/03/24/texte/</url>
      <content type="html"><![CDATA[<p><strong> hexo + node.js + GitHub Page创建博客：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>本文将详细介绍如何使用hexo + node.js 打造自己的轻量级博客<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>在学习前端不久，我在网上找资料，发现各位大神们都用博客记载文章，代码，或者一些教程，有些是第三方的，如简书，掘金（貌似这个是个社区），博客园等等之类的，但是也有很多通过hexo + Github Page来记录内容的，在无数次的观摩之后，我觉得我也该建立属于自己的博客了，毕竟自己的代码，自己的文章，自己心血，要好好保存，也是一个记录。</p><h2 id="第一步-需要下载node-js"><a href="#第一步-需要下载node-js" class="headerlink" title="第一步.需要下载node.js"></a>第一步.需要下载node.js</h2><ul><li><h3 id="因为Hexo是一只基于Node-js的静态博客框架，所以装node-js"><a href="#因为Hexo是一只基于Node-js的静态博客框架，所以装node-js" class="headerlink" title="因为Hexo是一只基于Node.js的静态博客框架，所以装node.js"></a>因为Hexo是一只基于Node.js的静态博客框架，所以装node.js</h3></li><li><h3 id="我们通过命令行来下载所需要的资源，方便快捷"><a href="#我们通过命令行来下载所需要的资源，方便快捷" class="headerlink" title="我们通过命令行来下载所需要的资源，方便快捷"></a>我们通过命令行来下载所需要的资源，方便快捷</h3></li><li><h3 id="具体安装过程请参阅"><a href="#具体安装过程请参阅" class="headerlink" title="具体安装过程请参阅"></a>具体安装过程请参阅</h3><p><a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">node.js安装</a></p><p><a href="https://nodejs.org/en/#download" target="_blank" rel="noopener">node.js官方地址</a></p></li></ul><h2 id="第二步-创建Github账号，创建一个仓库，用来保管我们的代码"><a href="#第二步-创建Github账号，创建一个仓库，用来保管我们的代码" class="headerlink" title="第二步.创建Github账号，创建一个仓库，用来保管我们的代码"></a>第二步.创建Github账号，创建一个仓库，用来保管我们的代码</h2><ul><li><h3 id="具体请参阅这篇文章"><a href="#具体请参阅这篇文章" class="headerlink" title="具体请参阅这篇文章"></a>具体请参阅这篇文章</h3><p><a href="https://www.jianshu.com/p/b26250a547b2" target="_blank" rel="noopener">如何创建git空仓库</a></p></li><li><h3 id="新建一个以下格式的空仓库"><a href="#新建一个以下格式的空仓库" class="headerlink" title="新建一个以下格式的空仓库"></a>新建一个以下格式的空仓库</h3><p><code>yourGitHubName.github.io</code></p></li></ul><h2 id="第三步-注册七牛云空间储存"><a href="#第三步-注册七牛云空间储存" class="headerlink" title="第三步.注册七牛云空间储存"></a>第三步.注册七牛云空间储存</h2><p>因为我们在写博客的时候，需要图片或者照片等等，还有在创建博客的时候，需要一张图片作为头像。由于github的空间资源有限，所以我们需要一个图床来放图片资源，当博客中需要用到，请先将图片资源上传到七牛图床</p><p><strong>友情提示</strong>：七牛注册需要身份证验证，所以需要身边的朋友帮忙拍2张照片，一张是本人手持身份证正面照，一张是反面，然后提交真实信息，通过支付宝帮忙验证。一般情况下，一天以后就能通过验证。</p><h2 id="第四步-开始我们的博客搭建之旅"><a href="#第四步-开始我们的博客搭建之旅" class="headerlink" title="第四步.开始我们的博客搭建之旅"></a>第四步.开始我们的博客搭建之旅</h2><ul><li><h3 id="Hexo安装-所有的安装均为命令行操作-没有git的朋友可以通过windows的cmd来操作-操作方式是一样的"><a href="#Hexo安装-所有的安装均为命令行操作-没有git的朋友可以通过windows的cmd来操作-操作方式是一样的" class="headerlink" title="Hexo安装(所有的安装均为命令行操作,没有git的朋友可以通过windows的cmd来操作,操作方式是一样的)"></a>Hexo安装(所有的安装均为命令行操作,没有git的朋友可以通过windows的cmd来操作,操作方式是一样的)</h3><p><code>npm install -g hexo-cli</code></p><p>这是通过命令行来安装hexo框架,如果你不是前端开发者,你不会理会到命令行安装东西是多么方便快捷</p></li><li><h3 id="部署本地项目"><a href="#部署本地项目" class="headerlink" title="部署本地项目"></a>部署本地项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;   //&lt;folder&gt;为你打算给Hexo项目命名的文件名</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml    //网站配置文件</span><br><span class="line">├── package.json   //应用程序的信息</span><br><span class="line">├── scaffolds      //模版文件夹</span><br><span class="line"></span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts     //你推送的博文</span><br><span class="line">└── themes         //你的主题文件夹</span><br></pre></td></tr></table></figure></li><li><h3 id="新建博文-也是通过命令行"><a href="#新建博文-也是通过命令行" class="headerlink" title="新建博文,也是通过命令行"></a>新建博文,也是通过命令行</h3><p><code>hexo new 我的第一篇文章</code></p><p>INFO  Created: F:\blog\source_posts\我的第一篇博客.md</p><p>终端会立马输出上面的这一行,意为这片博客已经建好在F盘=&gt;blog文件夹=&gt;source=&gt;_posts 目录</p></li><li><h3 id="编辑博文的工具有很多-也可以在线编辑-找到对应的网站就可以了"><a href="#编辑博文的工具有很多-也可以在线编辑-找到对应的网站就可以了" class="headerlink" title="编辑博文的工具有很多,也可以在线编辑,找到对应的网站就可以了"></a>编辑博文的工具有很多,也可以在线编辑,找到对应的网站就可以了</h3><p>不过我推荐的是vscode 或者 sublime Text3 编辑,在网上找插件,就可以在编辑的同时预览了</p></li><li><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>配置的目的是,该博客能显示你的名字,挂载到github上,<br>找到根目录_config.yml文件,找到以下字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 懒人漫游                    //网站标题</span><br><span class="line">subtitle:                         //网站描述</span><br><span class="line">description:                      //个人描述</span><br><span class="line">author:                           //作者（你的名字）</span><br><span class="line">language: zh-Hans                 //语言</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>修改最下方# Deployment中相关内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Varonia/Varonia.github.io.git   //地址修改为你自己的GitHub地址</span><br></pre></td></tr></table></figure><p>注意:原始模板信息后必须要空格,也就是冒号之后价格空格</p></li><li><h3 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   //安装 git 部署插件</span><br><span class="line">hexo clean        //清除缓存</span><br><span class="line">hexo generate     //发布到博客上</span><br><span class="line">hexo deploy       //推送到github上</span><br></pre></td></tr></table></figure></li><li><h3 id="打开博客预览"><a href="#打开博客预览" class="headerlink" title="打开博客预览"></a>打开博客预览</h3></li></ul><h2 id="第五步-更换主题"><a href="#第五步-更换主题" class="headerlink" title="第五步.更换主题"></a>第五步.更换主题</h2><ul><li><h3 id="进入hexo官网-找到主题选项-进去之后找自己喜欢的模板"><a href="#进入hexo官网-找到主题选项-进去之后找自己喜欢的模板" class="headerlink" title="进入hexo官网,找到主题选项,进去之后找自己喜欢的模板"></a>进入hexo官网,找到主题选项,进去之后找自己喜欢的模板</h3><p>每个模板都有自己对应操作介绍,但是之前还是会有差别,多试几个模板,你就会找到其中的规律,如果你是前端,你可以制作自己的风格的模板,你会发现里面的css代码,js代码,模板代码,自己或多或少的接触过,如果你不是前端,那么很抱歉,你只能再去找另外的博文教你如何操作模板的更换了.不过仔细看的话,还是蛮容易的,哈哈哈.</p></li></ul></the>]]></content>
      
      
    </entry>
    
    <entry>
      <title>几种常见的布局</title>
      <link href="/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/"/>
      <url>/2018/03/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p><strong> 几种常见的布局：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>理解布局的概念<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="一-理解布局的概念"><a href="#一-理解布局的概念" class="headerlink" title="一:理解布局的概念"></a>一:理解布局的概念</h2><ul><li><h3 id="静态布局"><a href="#静态布局" class="headerlink" title="静态布局:"></a>静态布局:</h3><p>  浏览器中显示网页,通过横向或者纵向滚动条来查阅改页面内容,意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；</p></li><li><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局:"></a>弹性布局:</h3><p>  flex局部CSS3引入的一个很强大的布局方式,用来替代以前Web开发人员使用的一些复杂而易错hacks方法</p><p>  其中flex-flow是flex-direction和flex-wrap属性的简写形式,语法如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-flow:||</span><br><span class="line">flex-direction: row | row-reverse(相反) | column | colum-reverse;</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure></li><li><h3 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h3><p>  自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。你可以把自适应布局看作是静态布局的一个系列。就是说你看到的页面，里面元素的位置会变化而大小不会变化</p></li><li><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,inital-scale=1.0,maximum-scale=1.0,minimum-scale=1.0</span><br><span class="line">,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>name=”viewport” 名称=视图</li><li>width=device-width 页面宽度=设备宽度(可以理解为获取你手机的屏幕宽度)</li><li>initial-scale - 初始的缩放比例</li><li>minimum-scale - 允许用户缩放到的最小比例</li><li>maximum-scale - 允许用户缩放到的最大比例</li><li>user-scalable - 用户是否可以手动缩放</li></ul></li></ul><p>在做响应式布局的时候,必须以及一定要加上的重要头部代码.分别为不同的屏幕分辨率定义布局,同时，在每个布局中,即页面元素宽度随着窗口调整而自动适配。每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p><h2 id="二-响应式布局的步骤"><a href="#二-响应式布局的步骤" class="headerlink" title="二:响应式布局的步骤:"></a>二:响应式布局的步骤:</h2><ul><li><h3 id="布局及设置meta标签"><a href="#布局及设置meta标签" class="headerlink" title="布局及设置meta标签:"></a>布局及设置meta标签:</h3><p>  在写响应式布局之前,可以先完成非响应式布局,页面固定宽度大小,如果完成了非响应式那么我在去添加媒体查询（Media Query)和响应式代码。这种操作更容易实现响应式特性。</p><p>  当你完成当你已经完成了无响应的网站，做的第一件事是在你的 HTML 页面，粘贴下面的代码到和标签之间。这将设置屏幕按1：1的尺寸显示，在 iPhone 和其他智能手机的浏览器提供网站全视图浏览，并禁止用户缩放页面。</p><p>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot; /&gt;</code></p></li><li><h3 id="通过媒体查询来设置样式-media-query"><a href="#通过媒体查询来设置样式-media-query" class="headerlink" title="通过媒体查询来设置样式 :media query"></a>通过媒体查询来设置样式 :media query</h3><p>  media query是响应式设计的核心，它能够和浏览器进行沟通，告诉浏览器页面如何呈现，假如一个终端的分辨率小于980px，那么可以这样写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:980px)&#123;</span><br><span class="line">    #head&#123;&#125;</span><br><span class="line">    #content&#123;&#125;</span><br><span class="line">    #footer&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里面的样式会覆盖掉之前所定义的样式。</p></li></ul><ul><li><h3 id="设置多种视图宽度"><a href="#设置多种视图宽度" class="headerlink" title="设置多种视图宽度"></a>设置多种视图宽度</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**ipad**/</span><br><span class="line">@media only screen and (min-width:768px)and(max-width:1024px)&#123;&#125;</span><br><span class="line">/**iphone**/</span><br><span class="line">@media only screen and (width:320px)and (width:768px)&#123;&#125;</span><br></pre></td></tr></table></figure><p>  假如需要兼容ipad和iphone,就可以使用种写法.</p></li><li><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>  在做pc端的时候,我们习惯于写px作为像素单位,但是在移动端,在做响应式<br>  布局的时候,我们需要将字体也做成响应式的.根据屏幕的尺寸变化而变化,<br>  这个时候,我们需要用到css3新的单位,rem.<br>  rem是相对于根元素的字体大小的单位.我习惯称呼为动态rem.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:100%;&#125;</span><br><span class="line">//完成后，你可以定义响应式字体：</span><br><span class="line">@media (min-width:640px)&#123;body&#123;font-size:1rem;&#125;&#125;</span><br><span class="line">@media (min-width:960px)&#123;body&#123;font-size:1.2rem;&#125;&#125;</span><br><span class="line">@media (min-width:1200px)&#123;body&#123;font-size:1.5rem;&#125;&#125;</span><br></pre></td></tr></table></figure><p>  <strong>切记,!!!</strong>一定要重置根元素字体大小.</p></li></ul><p>下面有几个例子可以参考看看:</p><p><a href="http://js.jirengu.com/camusidemo/1/edit?html,output" target="_blank" rel="noopener">flex布局</a></p></the>]]></content>
      
      <categories>
          
          <category> 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命周期中的哪些钩子函数</title>
      <link href="/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/03/23/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p><strong> 生命周期中的哪些钩子函数：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>生命周期的钩子函数<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="关于学习-Vue-的生命周期钩子函数"><a href="#关于学习-Vue-的生命周期钩子函数" class="headerlink" title="关于学习 Vue 的生命周期钩子函数"></a>关于学习 Vue 的生命周期钩子函数</h2><p>我们需要详细的了解,这会在写代码的时候,达到事半功倍的效果,可以帮我们很快的找出错误和解决需要,详情请见<a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener">vue</a>的这个章节</p><p>在Vue的官方文档中,给出了生命周期图示<br><img src="http://upload-images.jianshu.io/upload_images/8168023-334da70244e85c6d..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图示"></p><p>我们可以看到,这个图描述的Vue的生命周期从创建实例到销毁的过程<br>下面我们详细的说说Vue中有哪些什么周期钩子函数</p><blockquote><p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p></blockquote><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate:"></a>beforeCreate:</h4><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p><h4 id="created"><a href="#created" class="headerlink" title="created:"></a>created:</h4><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><ul><li>可以拿到数据</li><li>可以调用实例和方法</li><li>在这个生命周期钩子函数中适宜做异步请求</li></ul><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount:"></a>beforeMount:</h4><p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br>也就是说DOM还未被渲染</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted:"></a>mounted:</h4><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>DOM已经被渲染,初始数据DOM渲染完毕,可以获取DOM</p><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p><h4 id="updated"><a href="#updated" class="headerlink" title="updated:"></a>updated:</h4><p>数据更新完毕,如果对数据做统一的处理,在updated中处理<br>,如果想分别区分不同的数据更新,同时对DOM操作,用nextTick</p><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h4 id="watch-对具体某个函数变化作统一处理"><a href="#watch-对具体某个函数变化作统一处理" class="headerlink" title="watch:对具体某个函数变化作统一处理"></a>watch:对具体某个函数变化作统一处理</h4><h4 id="nextTick-处理某个数据的某一次变化"><a href="#nextTick-处理某个数据的某一次变化" class="headerlink" title="nextTick:处理某个数据的某一次变化"></a>nextTick:处理某个数据的某一次变化</h4><h4 id="created-可以获取数据-调用一部数据-调用方法"><a href="#created-可以获取数据-调用一部数据-调用方法" class="headerlink" title="created:可以获取数据,调用一部数据,调用方法"></a>created:可以获取数据,调用一部数据,调用方法</h4><p>updata在nextTick之前触发</p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
